{"ast":null,"code":"/*\n * vasync.js: utilities for observable asynchronous control flow\n */\nvar mod_assert = require('assert');\n\nvar mod_events = require('events');\n\nvar mod_util = require('util');\n\nvar mod_verror = require('verror');\n/*\n * Public interface\n */\n\n\nexports.parallel = parallel;\nexports.forEachParallel = forEachParallel;\nexports.pipeline = pipeline;\nexports.tryEach = tryEach;\nexports.forEachPipeline = forEachPipeline;\nexports.filter = filter;\nexports.filterLimit = filterLimit;\nexports.filterSeries = filterSeries;\nexports.whilst = whilst;\nexports.queue = queue;\nexports.queuev = queuev;\nexports.barrier = barrier;\nexports.waterfall = waterfall;\n\nif (!global.setImmediate) {\n  global.setImmediate = function (func) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    args.unshift(0);\n    args.unshift(func);\n    setTimeout.apply(this, args);\n  };\n}\n/*\n * This is incorporated here from jsprim because jsprim ends up pulling in a lot\n * of dependencies.  If we end up needing more from jsprim, though, we should\n * add it back and rip out this function.\n */\n\n\nfunction isEmpty(obj) {\n  var key;\n\n  for (key in obj) {\n    return false;\n  }\n\n  return true;\n}\n/*\n * Given a set of functions that complete asynchronously using the standard\n * callback(err, result) pattern, invoke them all and merge the results.  See\n * README.md for details.\n */\n\n\nfunction parallel(args, callback) {\n  var funcs, rv, doneOne, i;\n  mod_assert.equal(typeof args, 'object', '\"args\" must be an object');\n  mod_assert.ok(Array.isArray(args['funcs']), '\"args.funcs\" must be specified and must be an array');\n  mod_assert.equal(typeof callback, 'function', 'callback argument must be specified and must be a function');\n  funcs = args['funcs'].slice(0);\n  rv = {\n    'operations': new Array(funcs.length),\n    'successes': [],\n    'ndone': 0,\n    'nerrors': 0\n  };\n\n  if (funcs.length === 0) {\n    setImmediate(function () {\n      callback(null, rv);\n    });\n    return rv;\n  }\n\n  doneOne = function doneOne(entry) {\n    return function (err, result) {\n      mod_assert.equal(entry['status'], 'pending');\n      entry['err'] = err;\n      entry['result'] = result;\n      entry['status'] = err ? 'fail' : 'ok';\n      if (err) rv['nerrors']++;else rv['successes'].push(result);\n      if (++rv['ndone'] < funcs.length) return;\n      var errors = rv['operations'].filter(function (ent) {\n        return ent['status'] == 'fail';\n      }).map(function (ent) {\n        return ent['err'];\n      });\n      if (errors.length > 0) callback(new mod_verror.MultiError(errors), rv);else callback(null, rv);\n    };\n  };\n\n  for (i = 0; i < funcs.length; i++) {\n    rv['operations'][i] = {\n      'func': funcs[i],\n      'funcname': funcs[i].name || '(anon)',\n      'status': 'pending'\n    };\n    funcs[i](doneOne(rv['operations'][i]));\n  }\n\n  return rv;\n}\n/*\n * Exactly like parallel, except that the input is specified as a single\n * function to invoke on N different inputs (rather than N functions).  \"args\"\n * must have the following fields:\n *\n *\tfunc\t\tasynchronous function to invoke on each input value\n *\n *\tinputs\t\tarray of input values\n */\n\n\nfunction forEachParallel(args, callback) {\n  var func, funcs;\n  mod_assert.equal(typeof args, 'object', '\"args\" must be an object');\n  mod_assert.equal(typeof args['func'], 'function', '\"args.func\" must be specified and must be a function');\n  mod_assert.ok(Array.isArray(args['inputs']), '\"args.inputs\" must be specified and must be an array');\n  func = args['func'];\n  funcs = args['inputs'].map(function (input) {\n    return function (subcallback) {\n      return func(input, subcallback);\n    };\n  });\n  return parallel({\n    'funcs': funcs\n  }, callback);\n}\n/*\n * Like parallel, but invokes functions in sequence rather than in parallel\n * and aborts if any function exits with failure.  Arguments include:\n *\n *    funcs\tinvoke the functions in parallel\n *\n *    arg\tfirst argument to each pipeline function\n */\n\n\nfunction pipeline(args, callback) {\n  mod_assert.equal(typeof args, 'object', '\"args\" must be an object');\n  mod_assert.ok(Array.isArray(args['funcs']), '\"args.funcs\" must be specified and must be an array');\n  var opts = {\n    'funcs': args['funcs'].slice(0),\n    'callback': callback,\n    'args': {\n      impl: 'pipeline',\n      uarg: args['arg']\n    },\n    'stop_when': 'error',\n    'res_type': 'rv'\n  };\n  return waterfall_impl(opts);\n}\n\nfunction tryEach(funcs, callback) {\n  mod_assert.ok(Array.isArray(funcs), '\"funcs\" must be specified and must be an array');\n  mod_assert.ok(arguments.length == 1 || typeof callback == 'function', '\"callback\" must be a function');\n  var opts = {\n    'funcs': funcs.slice(0),\n    'callback': callback,\n    'args': {\n      impl: 'tryEach'\n    },\n    'stop_when': 'success',\n    'res_type': 'array'\n  };\n  return waterfall_impl(opts);\n}\n/*\n * Exactly like pipeline, except that the input is specified as a single\n * function to invoke on N different inputs (rather than N functions).  \"args\"\n * must have the following fields:\n *\n *\tfunc\t\tasynchronous function to invoke on each input value\n *\n *\tinputs\t\tarray of input values\n */\n\n\nfunction forEachPipeline(args, callback) {\n  mod_assert.equal(typeof args, 'object', '\"args\" must be an object');\n  mod_assert.equal(typeof args['func'], 'function', '\"args.func\" must be specified and must be a function');\n  mod_assert.ok(Array.isArray(args['inputs']), '\"args.inputs\" must be specified and must be an array');\n  mod_assert.equal(typeof callback, 'function', 'callback argument must be specified and must be a function');\n  var func = args['func'];\n  var funcs = args['inputs'].map(function (input) {\n    return function (_, subcallback) {\n      return func(input, subcallback);\n    };\n  });\n  return pipeline({\n    'funcs': funcs\n  }, callback);\n}\n/*\n * async.js compatible filter, filterLimit, and filterSeries.  Takes an input\n * array, optionally a limit, and a single function to filter an array and will\n * callback with a new filtered array. This is effectively an asynchronous\n * version of Array.prototype.filter.\n */\n\n\nfunction filter(inputs, filterFunc, callback) {\n  return filterLimit(inputs, Infinity, filterFunc, callback);\n}\n\nfunction filterSeries(inputs, filterFunc, callback) {\n  return filterLimit(inputs, 1, filterFunc, callback);\n}\n\nfunction filterLimit(inputs, limit, filterFunc, callback) {\n  mod_assert.ok(Array.isArray(inputs), '\"inputs\" must be specified and must be an array');\n  mod_assert.equal(typeof limit, 'number', '\"limit\" must be a number');\n  mod_assert.equal(isNaN(limit), false, '\"limit\" must be a number');\n  mod_assert.equal(typeof filterFunc, 'function', '\"filterFunc\" must be specified and must be a function');\n  mod_assert.equal(typeof callback, 'function', '\"callback\" argument must be specified as a function');\n  var errors = [];\n  var q = queue(processInput, limit);\n  var results = [];\n\n  function processInput(input, cb) {\n    /*\n     * If the errors array has any members, an error was\n     * encountered in a previous invocation of filterFunc, so all\n     * future filtering will be skipped.\n     */\n    if (errors.length > 0) {\n      cb();\n      return;\n    }\n\n    filterFunc(input.elem, function inputFiltered(err, ans) {\n      /*\n       * We ensure here that a filterFunc callback is only\n       * ever invoked once.\n       */\n      if (results.hasOwnProperty(input.idx)) {\n        throw new mod_verror.VError('vasync.filter*: filterFunc idx %d ' + 'invoked its callback twice', input.idx);\n      }\n      /*\n       * The original element, as well as the answer \"ans\"\n       * (truth value) is stored to later be filtered when\n       * all outstanding jobs are finished.\n       */\n\n\n      results[input.idx] = {\n        elem: input.elem,\n        ans: !!ans\n      };\n      /*\n       * Any error encountered while filtering will result in\n       * all future operations being skipped, and the error\n       * object being returned in the users callback.\n       */\n\n      if (err) {\n        errors.push(err);\n        cb();\n        return;\n      }\n\n      cb();\n    });\n  }\n\n  q.once('end', function queueDrained() {\n    if (errors.length > 0) {\n      callback(mod_verror.errorFromList(errors));\n      return;\n    }\n    /*\n     * results is now an array of objects in the same order of the\n     * inputs array, where each object looks like:\n     *\n     * {\n     *     \"ans\": <true|false>,\n     *     \"elem\": <original input element>\n     * }\n     *\n     * we filter out elements that have a false \"ans\" value, and\n     * then map the array to contain only the input elements.\n     */\n\n\n    results = results.filter(function filterFalseInputs(input) {\n      return input.ans;\n    }).map(function mapInputElements(input) {\n      return input.elem;\n    });\n    callback(null, results);\n  });\n  inputs.forEach(function iterateInput(elem, idx) {\n    /*\n     * We retain the array index to ensure that order is\n     * maintained.\n     */\n    q.push({\n      elem: elem,\n      idx: idx\n    });\n  });\n  q.close();\n  return q;\n}\n/*\n * async-compatible \"whilst\" function, with a few notable exceptions/addons.\n *\n * 1. More strict typing of arguments (functions *must* be supplied).\n * 2. A callback function is required, not optional.\n * 3. An object is returned, not undefined.\n */\n\n\nfunction whilst(testFunc, iterateFunc, callback) {\n  mod_assert.equal(typeof testFunc, 'function', '\"testFunc\" must be specified and must be a function');\n  mod_assert.equal(typeof iterateFunc, 'function', '\"iterateFunc\" must be specified and must be a function');\n  mod_assert.equal(typeof callback, 'function', '\"callback\" argument must be specified as a function');\n  /*\n   * The object returned to the caller that provides a read-only\n   * interface to introspect this specific invocation of \"whilst\".\n   */\n\n  var o = {\n    'finished': false,\n    'iterations': 0\n  };\n  /*\n   * Store the last set of arguments from the final call to \"iterateFunc\".\n   * The arguments will be passed to the final callback when an error is\n   * encountered or when the testFunc returns false.\n   */\n\n  var args = [];\n\n  function iterate() {\n    var shouldContinue = testFunc();\n\n    if (!shouldContinue) {\n      /*\n       * The test condition is false - break out of the loop.\n       */\n      done();\n      return;\n    }\n    /* Bump iterations after testFunc but before iterateFunc. */\n\n\n    o.iterations++;\n    iterateFunc(function whilstIteration(err) {\n      /* Store the latest set of arguments seen. */\n      args = Array.prototype.slice.call(arguments);\n      /* Any error with iterateFunc will break the loop. */\n\n      if (err) {\n        done();\n        return;\n      }\n      /* Try again. */\n\n\n      setImmediate(iterate);\n    });\n  }\n\n  function done() {\n    mod_assert.ok(!o.finished, 'whilst already finished');\n    o.finished = true;\n    callback.apply(this, args);\n  }\n\n  setImmediate(iterate);\n  return o;\n}\n/*\n * async-compatible \"queue\" function.\n */\n\n\nfunction queue(worker, concurrency) {\n  return new WorkQueue({\n    'worker': worker,\n    'concurrency': concurrency\n  });\n}\n\nfunction queuev(args) {\n  return new WorkQueue(args);\n}\n\nfunction WorkQueue(args) {\n  mod_assert.ok(args.hasOwnProperty('worker'));\n  mod_assert.equal(typeof args['worker'], 'function');\n  mod_assert.ok(args.hasOwnProperty('concurrency'));\n  mod_assert.equal(typeof args['concurrency'], 'number');\n  mod_assert.equal(Math.floor(args['concurrency']), args['concurrency']);\n  mod_assert.ok(args['concurrency'] > 0);\n  mod_events.EventEmitter.call(this);\n  this.nextid = 0;\n  this.worker = args['worker'];\n  this.worker_name = args['worker'].name || 'anon';\n  this.npending = 0;\n  this.pending = {};\n  this.queued = [];\n  this.closed = false;\n  this.ended = false;\n  /* user-settable fields inherited from \"async\" interface */\n\n  this.concurrency = args['concurrency'];\n  this.saturated = undefined;\n  this.empty = undefined;\n  this.drain = undefined;\n}\n\nmod_util.inherits(WorkQueue, mod_events.EventEmitter);\n\nWorkQueue.prototype.push = function (tasks, callback) {\n  if (!Array.isArray(tasks)) return this.pushOne(tasks, callback);\n  var wq = this;\n  return tasks.map(function (task) {\n    return wq.pushOne(task, callback);\n  });\n};\n\nWorkQueue.prototype.updateConcurrency = function (concurrency) {\n  if (this.closed) throw new mod_verror.VError('update concurrency invoked after queue closed');\n  this.concurrency = concurrency;\n  this.dispatchNext();\n};\n\nWorkQueue.prototype.close = function () {\n  var wq = this;\n  if (wq.closed) return;\n  wq.closed = true;\n  /*\n   * If the queue is already empty, just fire the \"end\" event on the\n   * next tick.\n   */\n\n  if (wq.npending === 0 && wq.queued.length === 0) {\n    setImmediate(function () {\n      if (!wq.ended) {\n        wq.ended = true;\n        wq.emit('end');\n      }\n    });\n  }\n};\n/* private */\n\n\nWorkQueue.prototype.pushOne = function (task, callback) {\n  if (this.closed) throw new mod_verror.VError('push invoked after queue closed');\n  var id = ++this.nextid;\n  var entry = {\n    'id': id,\n    'task': task,\n    'callback': callback\n  };\n  this.queued.push(entry);\n  this.dispatchNext();\n  return id;\n};\n/* private */\n\n\nWorkQueue.prototype.dispatchNext = function () {\n  var wq = this;\n\n  if (wq.npending === 0 && wq.queued.length === 0) {\n    if (wq.drain) wq.drain();\n    wq.emit('drain');\n    /*\n     * The queue is closed; emit the final \"end\"\n     * event before we come to rest:\n     */\n\n    if (wq.closed) {\n      wq.ended = true;\n      wq.emit('end');\n    }\n  } else if (wq.queued.length > 0) {\n    while (wq.queued.length > 0 && wq.npending < wq.concurrency) {\n      var next = wq.queued.shift();\n      wq.dispatch(next);\n\n      if (wq.queued.length === 0) {\n        if (wq.empty) wq.empty();\n        wq.emit('empty');\n      }\n    }\n  }\n};\n\nWorkQueue.prototype.dispatch = function (entry) {\n  var wq = this;\n  mod_assert.ok(!this.pending.hasOwnProperty(entry['id']));\n  mod_assert.ok(this.npending < this.concurrency);\n  mod_assert.ok(!this.ended);\n  this.npending++;\n  this.pending[entry['id']] = entry;\n\n  if (this.npending === this.concurrency) {\n    if (this.saturated) this.saturated();\n    this.emit('saturated');\n  }\n  /*\n   * We invoke the worker function on the next tick so that callers can\n   * always assume that the callback is NOT invoked during the call to\n   * push() even if the queue is not at capacity.  It also avoids O(n)\n   * stack usage when used with synchronous worker functions.\n   */\n\n\n  setImmediate(function () {\n    wq.worker(entry['task'], function (err) {\n      --wq.npending;\n      delete wq.pending[entry['id']];\n      if (entry['callback']) entry['callback'].apply(null, arguments);\n      wq.dispatchNext();\n    });\n  });\n};\n\nWorkQueue.prototype.length = function () {\n  return this.queued.length;\n};\n\nWorkQueue.prototype.kill = function () {\n  this.killed = true;\n  this.queued = [];\n  this.drain = undefined;\n  this.close();\n};\n/*\n * Barriers coordinate multiple concurrent operations.\n */\n\n\nfunction barrier(args) {\n  return new Barrier(args);\n}\n\nfunction Barrier(args) {\n  mod_assert.ok(!args || !args['nrecent'] || typeof args['nrecent'] == 'number', '\"nrecent\" must have type \"number\"');\n  mod_events.EventEmitter.call(this);\n  var nrecent = args && args['nrecent'] ? args['nrecent'] : 10;\n\n  if (nrecent > 0) {\n    this.nrecent = nrecent;\n    this.recent = [];\n  }\n\n  this.pending = {};\n  this.scheduled = false;\n}\n\nmod_util.inherits(Barrier, mod_events.EventEmitter);\n\nBarrier.prototype.start = function (name) {\n  mod_assert.ok(!this.pending.hasOwnProperty(name), 'operation \"' + name + '\" is already pending');\n  this.pending[name] = Date.now();\n};\n\nBarrier.prototype.done = function (name) {\n  mod_assert.ok(this.pending.hasOwnProperty(name), 'operation \"' + name + '\" is not pending');\n\n  if (this.recent) {\n    this.recent.push({\n      'name': name,\n      'start': this.pending[name],\n      'done': Date.now()\n    });\n    if (this.recent.length > this.nrecent) this.recent.shift();\n  }\n\n  delete this.pending[name];\n  /*\n   * If we executed at least one operation and we're now empty, we should\n   * emit \"drain\".  But most code doesn't deal well with events being\n   * processed while they're executing, so we actually schedule this event\n   * for the next tick.\n   *\n   * We use the \"scheduled\" flag to avoid emitting multiple \"drain\" events\n   * on consecutive ticks if the user starts and ends another task during\n   * this tick.\n   */\n\n  if (!isEmpty(this.pending) || this.scheduled) return;\n  this.scheduled = true;\n  var self = this;\n  setImmediate(function () {\n    self.scheduled = false;\n    /*\n     * It's also possible that the user has started another task on\n     * the previous tick, in which case we really shouldn't emit\n     * \"drain\".\n     */\n\n    if (isEmpty(self.pending)) self.emit('drain');\n  });\n};\n/*\n * waterfall([ funcs ], callback): invoke each of the asynchronous functions\n * \"funcs\" in series.  Each function is passed any values emitted by the\n * previous function (none for the first function), followed by the callback to\n * invoke upon completion.  This callback must be invoked exactly once,\n * regardless of success or failure.  As conventional in Node, the first\n * argument to the callback indicates an error (if non-null).  Subsequent\n * arguments are passed to the next function in the \"funcs\" chain.\n *\n * If any function fails (i.e., calls its callback with an Error), then the\n * remaining functions are not invoked and \"callback\" is invoked with the error.\n *\n * The only difference between waterfall() and pipeline() are the arguments\n * passed to each function in the chain.  pipeline() always passes the same\n * argument followed by the callback, while waterfall() passes whatever values\n * were emitted by the previous function followed by the callback.\n */\n\n\nfunction waterfall(funcs, callback) {\n  mod_assert.ok(Array.isArray(funcs), '\"funcs\" must be specified and must be an array');\n  mod_assert.ok(arguments.length == 1 || typeof callback == 'function', '\"callback\" must be a function');\n  var opts = {\n    'funcs': funcs.slice(0),\n    'callback': callback,\n    'args': {\n      impl: 'waterfall'\n    },\n    'stop_when': 'error',\n    'res_type': 'values'\n  };\n  return waterfall_impl(opts);\n}\n/*\n * This function is used to implement vasync-functions that need to execute a\n * list of functions in a sequence, but differ in how they make use of the\n * intermediate callbacks and finall callback, as well as under what conditions\n * they stop executing the functions in the list. Examples of such functions\n * are `pipeline`, `waterfall`, and `tryEach`. See the documentation for those\n * functions to see how they operate.\n *\n * This function's behavior is influenced via the `opts` object that we pass\n * in. This object has the following layout:\n *\n * \t{\n * \t\t'funcs': array of functions\n * \t\t'callback': the final callback\n * \t\t'args': {\n * \t\t\t'impl': 'pipeline' or 'tryEach' or 'waterfall'\n * \t\t\t'uarg': the arg passed to each func for 'pipeline'\n * \t\t\t}\n * \t\t'stop_when': 'error' or 'success'\n * \t\t'res_type': 'values' or 'arrays' or 'rv'\n * \t}\n *\n * In the object, 'res_type' is used to indicate what the type of the result\n * values(s) is that we pass to the final callback. We secondarily use\n * 'args.impl' to adjust this behavior in an implementation-specific way. For\n * example, 'tryEach' only returns an array if it has more than 1 result passed\n * to the final callback. Otherwise, it passes a solitary value to the final\n * callback.\n *\n * In case it's not clear, 'rv' in the `res_type` member, is just the\n * result-value that we also return. This is the convention in functions that\n * originated in `vasync` (pipeline), but not in functions that originated in\n * `async` (waterfall, tryEach).\n */\n\n\nfunction waterfall_impl(opts) {\n  mod_assert.ok(typeof opts === 'object');\n\n  var rv, current, _next;\n\n  var funcs = opts.funcs;\n  var callback = opts.callback;\n  mod_assert.ok(Array.isArray(funcs), '\"opts.funcs\" must be specified and must be an array');\n  mod_assert.ok(arguments.length == 1, 'Function \"waterfall_impl\" must take only 1 arg');\n  mod_assert.ok(opts.res_type === 'values' || opts.res_type === 'array' || opts.res_type == 'rv', '\"opts.res_type\" must either be \"values\", \"array\", or \"rv\"');\n  mod_assert.ok(opts.stop_when === 'error' || opts.stop_when === 'success', '\"opts.stop_when\" must either be \"error\" or \"success\"');\n  mod_assert.ok(opts.args.impl === 'pipeline' || opts.args.impl === 'waterfall' || opts.args.impl === 'tryEach', '\"opts.args.impl\" must be \"pipeline\", \"waterfall\", or \"tryEach\"');\n\n  if (opts.args.impl === 'pipeline') {\n    mod_assert.ok(typeof opts.args.uarg !== undefined, '\"opts.args.uarg\" should be defined when pipeline is used');\n  }\n\n  rv = {\n    'operations': funcs.map(function (func) {\n      return {\n        'func': func,\n        'funcname': func.name || '(anon)',\n        'status': 'waiting'\n      };\n    }),\n    'successes': [],\n    'ndone': 0,\n    'nerrors': 0\n  };\n\n  if (funcs.length === 0) {\n    if (callback) setImmediate(function () {\n      var res = opts.args.impl === 'pipeline' ? rv : undefined;\n      callback(null, res);\n    });\n    return rv;\n  }\n\n  _next = function next(idx, err) {\n    /*\n     * Note that nfunc_args contains the args we will pass to the\n     * next func in the func-list the user gave us. Except for\n     * 'tryEach', which passes cb's. However, it will pass\n     * 'nfunc_args' to its final callback -- see below.\n     */\n    var res_key, nfunc_args, entry, nextentry;\n    if (err === undefined) err = null;\n\n    if (idx != current) {\n      throw new mod_verror.VError('vasync.waterfall: function %d (\"%s\") invoked ' + 'its callback twice', idx, rv['operations'][idx].funcname);\n    }\n\n    mod_assert.equal(idx, rv['ndone'], 'idx should be equal to ndone');\n    entry = rv['operations'][rv['ndone']++];\n\n    if (opts.args.impl === 'tryEach' || opts.args.impl === 'waterfall') {\n      nfunc_args = Array.prototype.slice.call(arguments, 2);\n      res_key = 'results';\n      entry['results'] = nfunc_args;\n    } else if (opts.args.impl === 'pipeline') {\n      nfunc_args = [opts.args.uarg];\n      res_key = 'result';\n      entry['result'] = arguments[2];\n    }\n\n    mod_assert.equal(entry['status'], 'pending', 'status should be pending');\n    entry['status'] = err ? 'fail' : 'ok';\n    entry['err'] = err;\n\n    if (err) {\n      rv['nerrors']++;\n    } else {\n      rv['successes'].push(entry[res_key]);\n    }\n\n    if (opts.stop_when === 'error' && err || opts.stop_when === 'success' && rv['successes'].length > 0 || rv['ndone'] == funcs.length) {\n      if (callback) {\n        if (opts.res_type === 'values' || opts.res_type === 'array' && nfunc_args.length <= 1) {\n          nfunc_args.unshift(err);\n          callback.apply(null, nfunc_args);\n        } else if (opts.res_type === 'array') {\n          callback(err, nfunc_args);\n        } else if (opts.res_type === 'rv') {\n          callback(err, rv);\n        }\n      }\n    } else {\n      nextentry = rv['operations'][rv['ndone']];\n      nextentry['status'] = 'pending';\n      current++;\n      nfunc_args.push(_next.bind(null, current));\n      setImmediate(function () {\n        var nfunc = nextentry['func'];\n        /*\n         * At first glance it may seem like this branch\n         * is superflous with the code above that\n         * branches on `opts.args.impl`. It may also\n         * seem like calling `nfunc.apply` is\n         * sufficient for both cases (after all we\n         * pushed `next.bind(null, current)` to the\n         * `nfunc_args` array), before we call\n         * `setImmediate()`. However, this is not the\n         * case, because the interface exposed by\n         * tryEach is different from the others. The\n         * others pass argument(s) from task to task.\n         * tryEach passes nothing but a callback\n         * (`next.bind` below). However, the callback\n         * itself _can_ be called with one or more\n         * results, which we collect into `nfunc_args`\n         * using the aformentioned `opts.args.impl`\n         * branch above, and which we pass to the\n         * callback via the `opts.res_type` branch\n         * above (where res_type is set to 'array').\n         */\n\n        if (opts.args.impl !== 'tryEach') {\n          nfunc.apply(null, nfunc_args);\n        } else {\n          nfunc(_next.bind(null, current));\n        }\n      });\n    }\n  };\n\n  rv['operations'][0]['status'] = 'pending';\n  current = 0;\n\n  if (opts.args.impl !== 'pipeline') {\n    funcs[0](_next.bind(null, current));\n  } else {\n    funcs[0](opts.args.uarg, _next.bind(null, current));\n  }\n\n  return rv;\n}","map":null,"metadata":{},"sourceType":"script"}