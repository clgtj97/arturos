{"ast":null,"code":"'use strict';\n\nvar assert = require('assert-plus');\n\nvar errors = require('restify-errors');\n\nvar path = require('path');\n\nvar send = require('send');\n\nvar shallowCopy = require('./utils/shallowCopy'); ///--- Globals\n\n\nvar MethodNotAllowedError = errors.MethodNotAllowedError;\nvar NotAuthorizedError = errors.NotAuthorizedError;\nvar ResourceNotFoundError = errors.ResourceNotFoundError;\n/**\n * Serves static files, with API similar to expressjs\n *\n * @public\n * @function serveStaticFiles\n * @param    {String} directory - the directory to serve files from\n * @param    {Object} opts - an options object, which is optional\n * @param    {Number} [opts.maxAge=0] - specify max age in millisecs\n * @param    {Boolean} [opts.etag=true] - enable/disable etag, default = true\n * @param    {Function} [opts.setHeaders] - set custom headers for the Files\n * (synchronously), The function is called as `fn(res, path, stat)`,\n * where the arguments are:\n *      `res` the response object\n *      `path` the file path that is being sent\n *      `stat` the stat object of the file that is being sent\n * @throws   {MethodNotAllowedError}\n * @throws   {NotAuthorizedError}\n * @throws   {ResourceNotFoundError}\n * @returns  {Function} Handler\n * @example\n * <caption>\n * The serveStaticFiles plugin allows you to map a GET route to a\n * directory on the disk\n * </caption>\n * server.get('/public/*', // don't forget the `/*`\n *      restify.plugins.serveStaticFiles('./documentation/v1')\n * );\n * @example\n * <caption>\n * The GET `route` and `directory` combination will serve a file\n * located in `./documentation/v1/index.html` when you attempt to hit\n * `http://localhost:8080/public/index.html`\n *\n * The plugin uses [send](https://github.com/pillarjs/send) under the hood\n * which is also used by `expressjs` to serve static files. Most of the options\n * that work with `send` will work with this plugin.\n *\n * The default file the plugin looks for is `index.html`\n * </caption>\n * server.get('/public/*',\n *      restify.plugins.serveStaticFiles('./documentation/v1', {\n *      maxAge: 3600000, // this is in millisecs\n *      etag: false,\n *      setHeaders: function setCustomHeaders(response, requestedPath, stat) {\n *              response.setHeader('restify-plugin-x', 'awesome');\n *          }\n *      })\n * );\n */\n\nfunction serveStaticFiles(directory, opts) {\n  // make a copy of the options that will be passed to send\n  var optionsPlugin = shallowCopy(opts || {});\n  var optionsSend = shallowCopy(opts || {}); // lets assert some options\n\n  assert.object(optionsSend, 'options');\n  assert.object(optionsPlugin, 'options');\n  assert.string(directory, 'directory'); // `send` library relies on `root` to specify the root folder\n  // to look for files\n\n  optionsSend.root = path.resolve(directory); // `setHeaders` is only understood by our plugin\n\n  if (optionsSend.setHeaders) {\n    delete optionsSend.setHeaders;\n  }\n\n  return function handleServeStaticFiles(req, res, next) {\n    // Check to make sure that this was either a GET or a HEAD request\n    if (req.method !== 'GET' && req.method !== 'HEAD') {\n      return next(new MethodNotAllowedError('%s', req.method));\n    } // we expect the params to have `*`:\n    // This allows the router to accept any file path\n\n\n    var requestedFile = req.params['*'] || 'index.html'; // This is used only for sending back correct error message text\n\n    var requestedFullPath = req.url; // Rely on `send` library to create a stream\n\n    var stream = send(req, requestedFile, optionsSend); // Lets handle the various events being emitted by send module\n    // stream has ended, must call `next()`\n\n    stream.on('end', function handleEnd() {\n      return next();\n    }); // when `send` encounters any `error`, we have the opportunity\n    // to handle the errors here\n\n    stream.on('error', function handleError(err) {\n      var respondWithError = null; // When file does not exist\n\n      if (err.statusCode === 404) {\n        respondWithError = new ResourceNotFoundError(requestedFullPath);\n      } else {\n        // or action is forbidden (like requesting a directory)\n        respondWithError = new NotAuthorizedError(requestedFullPath);\n      }\n\n      return next(respondWithError);\n    }); // If the request was for directory and that directory did not\n    // have index.html, this will be called\n\n    stream.on('directory', function handleDirectoryRequest() {\n      next(new NotAuthorizedError('%s', requestedFullPath));\n      return;\n    }); // stream is about to send headers, and custom headers must be\n    // set now\n\n    stream.on('headers', function handleCustomHeaders(response, requestedPath, stat) {\n      if (optionsPlugin.setHeaders && typeof optionsPlugin.setHeaders === 'function') {\n        optionsPlugin.setHeaders(response, requestedPath, stat);\n      }\n    }); // pipe the stream into response\n\n    return stream.pipe(res);\n  };\n}\n\nmodule.exports = serveStaticFiles;","map":null,"metadata":{},"sourceType":"script"}