{"ast":null,"code":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n'use strict';\n\nvar fs = require('fs');\n\nvar assert = require('assert-plus');\n\nvar formidable = require('formidable');\n\nvar once = require('once');\n\nvar errors = require('restify-errors');\n\nvar vasync = require('vasync'); ///--- API\n\n/**\n * Returns a plugin that will parse the HTTP request body IFF the\n * contentType is multipart/form-data\n *\n * If req.params already contains a given key, that key is skipped and an\n * error is logged.\n *\n * @public\n * @function multipartBodyParser\n * @param    {Object}          options - an options object\n * @throws   {BadRequestError}\n * @returns  {Function} Handler\n */\n\n\nfunction multipartBodyParser(options) {\n  var opts = options || {};\n  assert.object(opts, 'opts');\n  assert.optionalBool(opts.overrideParams, 'opts.overrideParams');\n  assert.optionalBool(opts.multiples, 'opts.multiples');\n  assert.optionalBool(opts.keepExtensions, 'opts.keepExtensions');\n  assert.optionalString(opts.uploadDir, 'opts.uploadDir');\n  assert.optionalNumber(opts.maxFieldsSize, 'opts.maxFieldsSize');\n  assert.optionalString(opts.hash, 'opts.hash');\n  assert.optionalFunc(opts.multipartFileHandler, 'opts.multipartFileHandler');\n  assert.optionalFunc(opts.multipartHandler, 'opts.multipartHandler');\n  assert.optionalBool(opts.mapParams, 'opts.mapParams');\n  assert.optionalBool(opts.mapFiles, 'opts.mapFiles');\n  assert.optionalNumber(opts.maxFileSize, 'opts.maxFileSize');\n  var override = opts.overrideParams;\n\n  function parseMultipartBody(req, res, originalNext) {\n    // save original body on req.rawBody and req._body\n    req.rawBody = req._body = undefined;\n    var next = once(originalNext);\n\n    if (req.getContentType() !== 'multipart/form-data' || req.getContentLength() === 0 && !req.isChunked()) {\n      return next();\n    }\n\n    var form = new formidable.IncomingForm(); // enable multiple files on a single upload field\n    // (html5 multiple attribute)\n\n    form.multiples = opts.multiples || false;\n    form.keepExtensions = opts.keepExtensions ? true : false;\n\n    if (opts.uploadDir) {\n      form.uploadDir = opts.uploadDir;\n    }\n\n    if (opts.maxFieldsSize) {\n      form.maxFieldsSize = opts.maxFieldsSize;\n    }\n\n    if (opts.maxFileSize) {\n      form.maxFileSize = opts.maxFileSize;\n    }\n\n    if (opts.hash) {\n      form.hash = opts.hash;\n    }\n\n    form.onPart = function onPart(part) {\n      if (part.filename && opts.multipartFileHandler) {\n        opts.multipartFileHandler(part, req);\n      } else if (!part.filename && opts.multipartHandler) {\n        opts.multipartHandler(part, req);\n      } else {\n        form.handlePart(part);\n      }\n    };\n\n    return form.parse(req, function parse(err, fields, files) {\n      if (err) {\n        return next(new errors.BadRequestError(err.message));\n      }\n\n      req.body = fields;\n      req.files = files;\n\n      if (opts.mapParams !== false) {\n        Object.keys(fields).forEach(function forEach(k) {\n          if (req.params[k] && !override) {\n            return;\n          }\n\n          req.params[k] = fields[k];\n        });\n\n        if (opts.mapFiles) {\n          var barrier = vasync.barrier();\n          barrier.on('drain', function onDrain() {\n            return next();\n          });\n          barrier.start('fs');\n          Object.keys(files).forEach(function forEach(f) {\n            if (req.params[f] && !override) {\n              return;\n            }\n\n            barrier.start('fs' + f);\n            fs.readFile(files[f].path, function readFile(ex, data) {\n              barrier.done('fs' + f);\n              /*\n               * We want to stop the request here, if there's\n               * an error trying to read the file from disk.\n               * Ideally we'd like to stop the other oustanding\n               * file reads too, but there's no way to cancel\n               * in flight fs reads.  So we just return an\n               * error, and be grudgingly let the other file\n               * reads finish.\n               */\n\n              if (ex) {\n                return next(new errors.InternalError(ex, 'unable to read file' + f));\n              }\n\n              req.params[f] = data;\n              return true;\n            });\n          });\n          barrier.done('fs');\n          return false;\n        } else {\n          return next();\n        }\n      } else {\n        return next();\n      }\n    });\n  }\n\n  return parseMultipartBody;\n}\n\nmodule.exports = multipartBodyParser;","map":null,"metadata":{},"sourceType":"script"}