{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar thing = require('handle-thing');\n\nvar httpDeceiver = require('http-deceiver');\n\nvar util = require('util');\n\nfunction Handle(options, stream, socket) {\n  var state = {};\n  this._spdyState = state;\n  state.options = options || {};\n  state.stream = stream;\n  state.socket = null;\n  state.rawSocket = socket || stream.connection.socket;\n  state.deceiver = null;\n  state.ending = false;\n  var self = this;\n  thing.call(this, stream, {\n    getPeerName: function getPeerName() {\n      return self._getPeerName();\n    },\n    close: function close(callback) {\n      return self._closeCallback(callback);\n    }\n  });\n\n  if (!state.stream) {\n    this.on('stream', function (stream) {\n      state.stream = stream;\n    });\n  }\n}\n\nutil.inherits(Handle, thing);\nmodule.exports = Handle;\n\nHandle.create = function create(options, stream, socket) {\n  return new Handle(options, stream, socket);\n};\n\nHandle.prototype._getPeerName = function _getPeerName() {\n  var state = this._spdyState;\n\n  if (state.rawSocket._getpeername) {\n    return state.rawSocket._getpeername();\n  }\n\n  return null;\n};\n\nHandle.prototype._closeCallback = function _closeCallback(callback) {\n  var state = this._spdyState;\n  var stream = state.stream;\n\n  if (state.ending) {\n    // The .end() method of the stream may be called by us or by the\n    // .shutdown() method in our super-class. If the latter has already been\n    // called, then calling the .end() method below will have no effect, with\n    // the result that the callback will never get executed, leading to an ever\n    // so subtle memory leak.\n    if (stream._writableState.finished) {\n      // NOTE: it is important to call `setImmediate` instead of `nextTick`,\n      // since this is how regular `handle.close()` works in node.js core.\n      //\n      // Using `nextTick` will lead to `net.Socket` emitting `close` before\n      // `end` on UV_EOF. This results in aborted request without `end` event.\n      setImmediate(callback);\n    } else if (stream._writableState.ending) {\n      stream.once('finish', function () {\n        callback(null);\n      });\n    } else {\n      stream.end(callback);\n    }\n  } else {\n    stream.abort(callback);\n  } // Only a single end is allowed\n\n\n  state.ending = false;\n};\n\nHandle.prototype.getStream = function getStream(callback) {\n  var state = this._spdyState;\n\n  if (!callback) {\n    assert(state.stream);\n    return state.stream;\n  }\n\n  if (state.stream) {\n    process.nextTick(function () {\n      callback(state.stream);\n    });\n    return;\n  }\n\n  this.on('stream', callback);\n};\n\nHandle.prototype.assignSocket = function assignSocket(socket, options) {\n  var state = this._spdyState;\n  state.socket = socket;\n  state.deceiver = httpDeceiver.create(socket, options);\n\n  function onStreamError(err) {\n    state.socket.emit('error', err);\n  }\n\n  this.getStream(function (stream) {\n    stream.on('error', onStreamError);\n  });\n};\n\nHandle.prototype.assignClientRequest = function assignClientRequest(req) {\n  var state = this._spdyState;\n  var oldEnd = req.end;\n  var oldSend = req._send; // Catch the headers before request will be sent\n\n  var self = this; // For old nodes\n\n  if (thing.mode !== 'modern') {\n    req.end = function end() {\n      this.end = oldEnd;\n\n      this._send('');\n\n      return this.end.apply(this, arguments);\n    };\n  }\n\n  req._send = function send(data) {\n    this._headerSent = true; // for v0.10 and below, otherwise it will set `hot = false` and include\n    // headers in first write\n\n    this._header = 'ignore me'; // To prevent exception\n\n    this.connection = state.socket; // It is very important to leave this here, otherwise it will be executed\n    // on a next tick, after `_send` will perform write\n\n    self.getStream(function (stream) {\n      if (!stream.connection._isGoaway(stream.id)) {\n        stream.send();\n      }\n    }); // We are ready to create stream\n\n    self.emit('needStream'); // Ensure that the connection is still ok to use\n\n    if (state.stream && state.stream.connection._isGoaway(state.stream.id)) {\n      return;\n    }\n\n    req._send = oldSend; // Ignore empty writes\n\n    if (req.method === 'GET' && data.length === 0) {\n      return;\n    }\n\n    return req._send.apply(this, arguments);\n  }; // No chunked encoding\n\n\n  req.useChunkedEncodingByDefault = false;\n  req.on('finish', function () {\n    req.socket.end();\n  });\n};\n\nHandle.prototype.assignRequest = function assignRequest(req) {\n  // Emit trailing headers\n  this.getStream(function (stream) {\n    stream.on('headers', function (headers) {\n      req.emit('trailers', headers);\n    });\n  });\n};\n\nHandle.prototype.assignResponse = function assignResponse(res) {\n  var self = this;\n\n  res.addTrailers = function addTrailers(headers) {\n    self.getStream(function (stream) {\n      stream.sendHeaders(headers);\n    });\n  };\n};\n\nHandle.prototype._transformHeaders = function _transformHeaders(kind, headers) {\n  var state = this._spdyState;\n  var res = {};\n  var keys = Object.keys(headers);\n\n  if (kind === 'request' && state.options['x-forwarded-for']) {\n    var xforwarded = state.stream.connection.getXForwardedFor();\n\n    if (xforwarded !== null) {\n      res['x-forwarded-for'] = xforwarded;\n    }\n  }\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = headers[key];\n\n    if (key === ':authority') {\n      res.host = value;\n    }\n\n    if (/^:/.test(key)) {\n      continue;\n    }\n\n    res[key] = value;\n  }\n\n  return res;\n};\n\nHandle.prototype.emitRequest = function emitRequest() {\n  var state = this._spdyState;\n  var stream = state.stream;\n  state.deceiver.emitRequest({\n    method: stream.method,\n    path: stream.path,\n    headers: this._transformHeaders('request', stream.headers)\n  });\n};\n\nHandle.prototype.emitResponse = function emitResponse(status, headers) {\n  var state = this._spdyState;\n  state.deceiver.emitResponse({\n    status: status,\n    headers: this._transformHeaders('response', headers)\n  });\n};","map":null,"metadata":{},"sourceType":"script"}