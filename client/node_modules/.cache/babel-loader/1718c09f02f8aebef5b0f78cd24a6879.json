{"ast":null,"code":"'use strict'; // core modules\n\nvar util = require('util'); // external modules\n\n\nvar assert = require('assert-plus');\n\nvar verror = require('verror'); // internal files\n\n\nvar helpers = require('./../helpers');\n/**\n * Base HttpError class. inherits from WError.\n * Variadic signature, first two are special to Restify, using a options obj.\n * 1) new HttpError(anotherErr, {...});\n * 2) new HttpError({...});\n * Last one is a straight pass through to WError\n * 3) new HttpError('my special error message');\n * @public\n * @class\n */\n\n\nfunction HttpError() {\n  var self = this;\n  var parsed = helpers.parseVErrorArgs(arguments);\n  var verrorArgs = parsed.verrorArgs.length !== 0 ? parsed.verrorArgs : [self.message];\n  var opts = parsed.internalOpts; // if we have opts for use with restify-error's constructors, assert on them\n  // now.\n\n  assert.optionalNumber(opts.statusCode, 'opts.statusCode');\n  assert.optionalFunc(opts.toJSON, 'opts.toJSON');\n  assert.optionalFunc(opts.toString, 'opts.toString'); // inherit from WError, call super first before doing anything else!  WError\n  // will handle calling captureStackTrace, using arguments.callee to\n  // eliminate unnecessary stack frames.\n\n  verror.WError.apply(self, verrorArgs);\n  /**\n   * the http status code of the error.\n   * because inherited classes have status code set on the prototype,\n   * only assign a status code if truthy.\n   * @property\n   * @type {Number}\n   */\n\n  if (opts.statusCode) {\n    self.statusCode = opts.statusCode;\n  }\n  /**\n   * property used to describe the error. emulates some of the core module\n   * errors that have codes on them to describe their nature,\n   * i.e., fs.readFile can return an ENOENT error where err.code is 'ENOENT'\n   * @property\n   * @type {String}\n   */\n\n\n  if (opts.code) {\n    self.code = opts.code;\n  }\n  /**\n   * an object used to render the error when serialized (JSON.stringify or\n   * toString)\n   * @property\n   * @type {Object}\n   */\n\n\n  self.body = {\n    // err.code/err.restCode is used by legacy restify paths, probably\n    // originally created to emulate the code property that is created by\n    // some native core module errors (i.e., a failed fs.readFile will\n    // return a ENOENT error with a err.code of ENOENT).\n    //\n    // for Http/RestErrors, the code will be the error name but with\n    // 'error' truncated from the string. i.e., if the error name is\n    // InternalServerError, the code is InternalServer.\n    code: opts.code || self.code,\n    message: self.message || ''\n  };\n  /**\n   * override prototype toJSON method. must use 'hasOwnProperty' to ensure we\n   * are picking up a user specified option vs the one set on object literals.\n   * @property\n   * @type {Function}\n   */\n\n  if (opts.hasOwnProperty('toJSON')) {\n    self.toJSON = opts.toJSON;\n  }\n  /**\n   * override prototype toJSON method. must use 'hasOwnProperty' to ensure we\n   * are picking up a user specified option vs the one set on object literals.\n   * @property\n   * @type {Function}\n   */\n\n\n  if (opts.hasOwnProperty('toString')) {\n    self.toString = opts.toString;\n  }\n}\n\nutil.inherits(HttpError, verror.WError);\n/**\n * migration method to allow continued use of `.context` property that has now\n * been migrated to use VError's info object under the hood.\n * @type {Object}\n */\n\nObject.defineProperty(HttpError.prototype, 'context', {\n  get: function getContext() {\n    var self = this;\n    return verror.info(self);\n  }\n});\n/**\n * assign non-standard display name property on the CONSTRUCTOR (not prototype),\n * which is supported by all VMs. useful for stack trace output.\n * @type {String}\n */\n\nHttpError.displayName = 'HttpError';\n/**\n * the name of the error, used in the stack trace output\n * @type {String}\n */\n\nHttpError.prototype.name = 'HttpError';\n/**\n * the default error code\n * @type {String}\n */\n\nHttpError.prototype.code = 'Error';\n/**\n * implement a basic toString/JSON.stringify. they should be identical.\n * @public\n * @method toJSON\n * @returns {String}\n */\n\nHttpError.prototype.toJSON = function toJSON() {\n  var self = this;\n  var message = ''; // if we have a cause, get the full VError toString() without the current\n  // error name. verbose check, self.cause can exist but returns undefined\n\n  if (self.cause && typeof self.cause === 'function' && self.cause()) {\n    var fullString = self.toString();\n    message = fullString.substr(fullString.indexOf(' ') + 1);\n  } else {\n    message = self.body.message;\n  }\n\n  return {\n    code: self.body.code,\n    message: message\n  };\n};\n\nmodule.exports = HttpError;","map":null,"metadata":{},"sourceType":"script"}