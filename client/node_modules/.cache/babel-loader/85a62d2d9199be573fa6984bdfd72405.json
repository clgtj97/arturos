{"ast":null,"code":"'use strict';\n/*\n  Char codes:\n    '#': 35\n    '*': 42\n    '-': 45\n    '/': 47\n    ':': 58\n    ';': 59\n    '?': 63\n*/\n\nvar assert = require('assert');\n\nvar http = require('http');\n\nvar fastDecode = require('fast-decode-uri-component');\n\nvar isRegexSafe = require('safe-regex2');\n\nvar Node = require('./node');\n\nvar NODE_TYPES = Node.prototype.types;\nvar httpMethods = http.METHODS;\nvar FULL_PATH_REGEXP = /^https?:\\/\\/.*\\//;\n\nif (!isRegexSafe(FULL_PATH_REGEXP)) {\n  throw new Error('the FULL_PATH_REGEXP is not safe, update this module');\n}\n\nvar acceptVersionStrategy = require('./lib/accept-version');\n\nfunction Router(opts) {\n  if (!(this instanceof Router)) {\n    return new Router(opts);\n  }\n\n  opts = opts || {};\n\n  if (opts.defaultRoute) {\n    assert(typeof opts.defaultRoute === 'function', 'The default route must be a function');\n    this.defaultRoute = opts.defaultRoute;\n  } else {\n    this.defaultRoute = null;\n  }\n\n  this.caseSensitive = opts.caseSensitive === undefined ? true : opts.caseSensitive;\n  this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false;\n  this.maxParamLength = opts.maxParamLength || 100;\n  this.allowUnsafeRegex = opts.allowUnsafeRegex || false;\n  this.versioning = opts.versioning || acceptVersionStrategy;\n  this.tree = new Node({\n    versions: this.versioning.storage()\n  });\n  this.routes = [];\n}\n\nRouter.prototype.on = function on(method, path, opts, handler, store) {\n  if (typeof opts === 'function') {\n    if (handler !== undefined) {\n      store = handler;\n    }\n\n    handler = opts;\n    opts = {};\n  } // path validation\n\n\n  assert(typeof path === 'string', 'Path should be a string');\n  assert(path.length > 0, 'The path could not be empty');\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`'); // handler validation\n\n  assert(typeof handler === 'function', 'Handler should be a function');\n\n  this._on(method, path, opts, handler, store);\n\n  if (this.ignoreTrailingSlash && path !== '/' && !path.endsWith('*')) {\n    if (path.endsWith('/')) {\n      this._on(method, path.slice(0, -1), opts, handler, store);\n    } else {\n      this._on(method, path + '/', opts, handler, store);\n    }\n  }\n};\n\nRouter.prototype._on = function _on(method, path, opts, handler, store) {\n  if (Array.isArray(method)) {\n    for (var k = 0; k < method.length; k++) {\n      this._on(method[k], path, opts, handler, store);\n    }\n\n    return;\n  } // method validation\n\n\n  assert(typeof method === 'string', 'Method should be a string');\n  assert(httpMethods.indexOf(method) !== -1, \"Method '\".concat(method, \"' is not an http method.\"));\n  var params = [];\n  var j = 0;\n  this.routes.push({\n    method: method,\n    path: path,\n    opts: opts,\n    handler: handler,\n    store: store\n  });\n  var version = opts.version;\n\n  for (var i = 0, len = path.length; i < len; i++) {\n    // search for parametric or wildcard routes\n    // parametric route\n    if (path.charCodeAt(i) === 58) {\n      var nodeType = NODE_TYPES.PARAM;\n      j = i + 1;\n      var staticPart = path.slice(0, i);\n\n      if (this.caseSensitive === false) {\n        staticPart = staticPart.toLowerCase();\n      } // add the static part of the route to the tree\n\n\n      this._insert(method, staticPart, 0, null, null, null, null, version); // isolate the parameter name\n\n\n      var isRegex = false;\n\n      while (i < len && path.charCodeAt(i) !== 47) {\n        isRegex = isRegex || path[i] === '(';\n\n        if (isRegex) {\n          i = getClosingParenthensePosition(path, i) + 1;\n          break;\n        } else if (path.charCodeAt(i) !== 45) {\n          i++;\n        } else {\n          break;\n        }\n      }\n\n      if (isRegex && (i === len || path.charCodeAt(i) === 47)) {\n        nodeType = NODE_TYPES.REGEX;\n      } else if (i < len && path.charCodeAt(i) !== 47) {\n        nodeType = NODE_TYPES.MULTI_PARAM;\n      }\n\n      var parameter = path.slice(j, i);\n      var regex = isRegex ? parameter.slice(parameter.indexOf('('), i) : null;\n\n      if (isRegex) {\n        regex = new RegExp(regex);\n\n        if (!this.allowUnsafeRegex) {\n          assert(isRegexSafe(regex), \"The regex '\".concat(regex.toString(), \"' is not safe!\"));\n        }\n      }\n\n      params.push(parameter.slice(0, isRegex ? parameter.indexOf('(') : i));\n      path = path.slice(0, j) + path.slice(i);\n      i = j;\n      len = path.length; // if the path is ended\n\n      if (i === len) {\n        var completedPath = path.slice(0, i);\n\n        if (this.caseSensitive === false) {\n          completedPath = completedPath.toLowerCase();\n        }\n\n        return this._insert(method, completedPath, nodeType, params, handler, store, regex, version);\n      } // add the parameter and continue with the search\n\n\n      this._insert(method, path.slice(0, i), nodeType, params, null, null, regex, version);\n\n      i--; // wildcard route\n    } else if (path.charCodeAt(i) === 42) {\n      this._insert(method, path.slice(0, i), 0, null, null, null, null, version); // add the wildcard parameter\n\n\n      params.push('*');\n      return this._insert(method, path.slice(0, len), 2, params, handler, store, null, version);\n    }\n  }\n\n  if (this.caseSensitive === false) {\n    path = path.toLowerCase();\n  } // static route\n\n\n  this._insert(method, path, 0, params, handler, store, null, version);\n};\n\nRouter.prototype._insert = function _insert(method, path, kind, params, handler, store, regex, version) {\n  var route = path;\n  var currentNode = this.tree;\n  var prefix = '';\n  var pathLen = 0;\n  var prefixLen = 0;\n  var len = 0;\n  var max = 0;\n  var node = null;\n\n  while (true) {\n    prefix = currentNode.prefix;\n    prefixLen = prefix.length;\n    pathLen = path.length;\n    len = 0; // search for the longest common prefix\n\n    max = pathLen < prefixLen ? pathLen : prefixLen;\n\n    while (len < max && path[len] === prefix[len]) {\n      len++;\n    } // the longest common prefix is smaller than the current prefix\n    // let's split the node and add a new child\n\n\n    if (len < prefixLen) {\n      node = new Node({\n        prefix: prefix.slice(len),\n        children: currentNode.children,\n        kind: currentNode.kind,\n        handlers: new Node.Handlers(currentNode.handlers),\n        regex: currentNode.regex,\n        versions: currentNode.versions\n      });\n\n      if (currentNode.wildcardChild !== null) {\n        node.wildcardChild = currentNode.wildcardChild;\n      } // reset the parent\n\n\n      currentNode.reset(prefix.slice(0, len), this.versioning.storage()).addChild(node); // if the longest common prefix has the same length of the current path\n      // the handler should be added to the current node, to a child otherwise\n\n      if (len === pathLen) {\n        if (version) {\n          assert(!currentNode.getVersionHandler(version, method), \"Method '\".concat(method, \"' already declared for route '\").concat(route, \"' version '\").concat(version, \"'\"));\n          currentNode.setVersionHandler(version, method, handler, params, store);\n        } else {\n          assert(!currentNode.getHandler(method), \"Method '\".concat(method, \"' already declared for route '\").concat(route, \"'\"));\n          currentNode.setHandler(method, handler, params, store);\n        }\n\n        currentNode.kind = kind;\n      } else {\n        node = new Node({\n          prefix: path.slice(len),\n          kind: kind,\n          handlers: null,\n          regex: regex,\n          versions: this.versioning.storage()\n        });\n\n        if (version) {\n          node.setVersionHandler(version, method, handler, params, store);\n        } else {\n          node.setHandler(method, handler, params, store);\n        }\n\n        currentNode.addChild(node);\n      } // the longest common prefix is smaller than the path length,\n      // but is higher than the prefix\n\n    } else if (len < pathLen) {\n      // remove the prefix\n      path = path.slice(len); // check if there is a child with the label extracted from the new path\n\n      node = currentNode.findByLabel(path); // there is a child within the given label, we must go deepen in the tree\n\n      if (node) {\n        currentNode = node;\n        continue;\n      } // there are not children within the given label, let's create a new one!\n\n\n      node = new Node({\n        prefix: path,\n        kind: kind,\n        handlers: null,\n        regex: regex,\n        versions: this.versioning.storage()\n      });\n\n      if (version) {\n        node.setVersionHandler(version, method, handler, params, store);\n      } else {\n        node.setHandler(method, handler, params, store);\n      }\n\n      currentNode.addChild(node); // the node already exist\n    } else if (handler) {\n      if (version) {\n        assert(!currentNode.getVersionHandler(version, method), \"Method '\".concat(method, \"' already declared for route '\").concat(route, \"' version '\").concat(version, \"'\"));\n        currentNode.setVersionHandler(version, method, handler, params, store);\n      } else {\n        assert(!currentNode.getHandler(method), \"Method '\".concat(method, \"' already declared for route '\").concat(route, \"'\"));\n        currentNode.setHandler(method, handler, params, store);\n      }\n    }\n\n    return;\n  }\n};\n\nRouter.prototype.reset = function reset() {\n  this.tree = new Node({\n    versions: this.versioning.storage()\n  });\n  this.routes = [];\n};\n\nRouter.prototype.off = function off(method, path) {\n  var self = this;\n\n  if (Array.isArray(method)) {\n    return method.map(function (method) {\n      return self.off(method, path);\n    });\n  } // method validation\n\n\n  assert(typeof method === 'string', 'Method should be a string');\n  assert(httpMethods.indexOf(method) !== -1, \"Method '\".concat(method, \"' is not an http method.\")); // path validation\n\n  assert(typeof path === 'string', 'Path should be a string');\n  assert(path.length > 0, 'The path could not be empty');\n  assert(path[0] === '/' || path[0] === '*', 'The first character of a path should be `/` or `*`'); // Rebuild tree without the specific route\n\n  var ignoreTrailingSlash = this.ignoreTrailingSlash;\n  var newRoutes = self.routes.filter(function (route) {\n    if (!ignoreTrailingSlash) {\n      return !(method === route.method && path === route.path);\n    }\n\n    if (path.endsWith('/')) {\n      var _routeMatches = path === route.path || path.slice(0, -1) === route.path;\n\n      return !(method === route.method && _routeMatches);\n    }\n\n    var routeMatches = path === route.path || path + '/' === route.path;\n    return !(method === route.method && routeMatches);\n  });\n\n  if (ignoreTrailingSlash) {\n    newRoutes = newRoutes.filter(function (route, i, ar) {\n      if (route.path.endsWith('/') && i < ar.length - 1) {\n        return route.path.slice(0, -1) !== ar[i + 1].path;\n      } else if (route.path.endsWith('/') === false && i < ar.length - 1) {\n        return route.path + '/' !== ar[i + 1].path;\n      }\n\n      return true;\n    });\n  }\n\n  self.reset();\n  newRoutes.forEach(function (route) {\n    self.on(route.method, route.path, route.opts, route.handler, route.store);\n  });\n};\n\nRouter.prototype.lookup = function lookup(req, res, ctx) {\n  var handle = this.find(req.method, sanitizeUrl(req.url), this.versioning.deriveVersion(req, ctx));\n  if (handle === null) return this._defaultRoute(req, res, ctx);\n  return ctx === undefined ? handle.handler(req, res, handle.params, handle.store) : handle.handler.call(ctx, req, res, handle.params, handle.store);\n};\n\nRouter.prototype.find = function find(method, path, version) {\n  if (path.charCodeAt(0) !== 47) {\n    // 47 is '/'\n    path = path.replace(FULL_PATH_REGEXP, '/');\n  }\n\n  var originalPath = path;\n  var originalPathLength = path.length;\n\n  if (this.caseSensitive === false) {\n    path = path.toLowerCase();\n  }\n\n  var maxParamLength = this.maxParamLength;\n  var currentNode = this.tree;\n  var wildcardNode = null;\n  var pathLenWildcard = 0;\n  var decoded = null;\n  var pindex = 0;\n  var params = [];\n  var i = 0;\n  var idxInOriginalPath = 0;\n\n  while (true) {\n    var pathLen = path.length;\n    var prefix = currentNode.prefix;\n    var prefixLen = prefix.length;\n    var len = 0;\n    var previousPath = path; // found the route\n\n    if (pathLen === 0 || path === prefix) {\n      var handle = version === undefined ? currentNode.handlers[method] : currentNode.getVersionHandler(version, method);\n\n      if (handle !== null && handle !== undefined) {\n        var paramsObj = {};\n\n        if (handle.paramsLength > 0) {\n          var paramNames = handle.params;\n\n          for (i = 0; i < handle.paramsLength; i++) {\n            paramsObj[paramNames[i]] = params[i];\n          }\n        }\n\n        return {\n          handler: handle.handler,\n          params: paramsObj,\n          store: handle.store\n        };\n      }\n    } // search for the longest common prefix\n\n\n    i = pathLen < prefixLen ? pathLen : prefixLen;\n\n    while (len < i && path.charCodeAt(len) === prefix.charCodeAt(len)) {\n      len++;\n    }\n\n    if (len === prefixLen) {\n      path = path.slice(len);\n      pathLen = path.length;\n      idxInOriginalPath += len;\n    }\n\n    var node = version === undefined ? currentNode.findChild(path, method) : currentNode.findVersionChild(version, path, method);\n\n    if (node === null) {\n      node = currentNode.parametricBrother;\n\n      if (node === null) {\n        return getWildcardNode(wildcardNode, method, originalPath, pathLenWildcard);\n      }\n\n      if (originalPath.indexOf('/' + previousPath) === -1) {\n        // we need to know the outstanding path so far from the originalPath since the last encountered \"/\" and assign it to previousPath.\n        // e.g originalPath: /aa/bbb/cc, path: bb/cc\n        // outstanding path: /bbb/cc\n        var pathDiff = originalPath.slice(0, originalPathLength - pathLen);\n        previousPath = pathDiff.slice(pathDiff.lastIndexOf('/') + 1, pathDiff.length) + path;\n      }\n\n      idxInOriginalPath = idxInOriginalPath - (previousPath.length - path.length);\n      path = previousPath;\n      pathLen = previousPath.length;\n      len = prefixLen;\n    }\n\n    var kind = node.kind; // static route\n\n    if (kind === NODE_TYPES.STATIC) {\n      // if exist, save the wildcard child\n      if (currentNode.wildcardChild !== null) {\n        wildcardNode = currentNode.wildcardChild;\n        pathLenWildcard = pathLen;\n      }\n\n      currentNode = node;\n      continue;\n    }\n\n    if (len !== prefixLen) {\n      return getWildcardNode(wildcardNode, method, originalPath, pathLenWildcard);\n    } // if exist, save the wildcard child\n\n\n    if (currentNode.wildcardChild !== null) {\n      wildcardNode = currentNode.wildcardChild;\n      pathLenWildcard = pathLen;\n    } // parametric route\n\n\n    if (kind === NODE_TYPES.PARAM) {\n      currentNode = node;\n      i = path.indexOf('/');\n      if (i === -1) i = pathLen;\n      if (i > maxParamLength) return null;\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i));\n      if (decoded === null) return null;\n      params[pindex++] = decoded;\n      path = path.slice(i);\n      idxInOriginalPath += i;\n      continue;\n    } // wildcard route\n\n\n    if (kind === NODE_TYPES.MATCH_ALL) {\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath));\n      if (decoded === null) return null;\n      params[pindex] = decoded;\n      currentNode = node;\n      path = '';\n      continue;\n    } // parametric(regex) route\n\n\n    if (kind === NODE_TYPES.REGEX) {\n      currentNode = node;\n      i = path.indexOf('/');\n      if (i === -1) i = pathLen;\n      if (i > maxParamLength) return null;\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i));\n      if (decoded === null) return null;\n      if (!node.regex.test(decoded)) return null;\n      params[pindex++] = decoded;\n      path = path.slice(i);\n      idxInOriginalPath += i;\n      continue;\n    } // multiparametric route\n\n\n    if (kind === NODE_TYPES.MULTI_PARAM) {\n      currentNode = node;\n      i = 0;\n\n      if (node.regex !== null) {\n        var matchedParameter = path.match(node.regex);\n        if (matchedParameter === null) return null;\n        i = matchedParameter[1].length;\n      } else {\n        while (i < pathLen && path.charCodeAt(i) !== 47 && path.charCodeAt(i) !== 45) {\n          i++;\n        }\n\n        if (i > maxParamLength) return null;\n      }\n\n      decoded = fastDecode(originalPath.slice(idxInOriginalPath, idxInOriginalPath + i));\n      if (decoded === null) return null;\n      params[pindex++] = decoded;\n      path = path.slice(i);\n      idxInOriginalPath += i;\n      continue;\n    }\n\n    wildcardNode = null;\n  }\n};\n\nRouter.prototype._defaultRoute = function (req, res, ctx) {\n  if (this.defaultRoute !== null) {\n    return ctx === undefined ? this.defaultRoute(req, res) : this.defaultRoute.call(ctx, req, res);\n  } else {\n    res.statusCode = 404;\n    res.end();\n  }\n};\n\nRouter.prototype.prettyPrint = function () {\n  return this.tree.prettyPrint('', true);\n};\n\nvar _loop = function _loop() {\n  if (!http.METHODS.hasOwnProperty(i)) return \"continue\";\n  var m = http.METHODS[i];\n  var methodName = m.toLowerCase();\n  if (Router.prototype[methodName]) throw new Error('Method already exists: ' + methodName);\n\n  Router.prototype[methodName] = function (path, handler, store) {\n    return this.on(m, path, handler, store);\n  };\n};\n\nfor (var i in http.METHODS) {\n  var _ret = _loop();\n\n  if (_ret === \"continue\") continue;\n}\n\nRouter.prototype.all = function (path, handler, store) {\n  this.on(httpMethods, path, handler, store);\n};\n\nmodule.exports = Router;\n\nfunction sanitizeUrl(url) {\n  for (var i = 0, len = url.length; i < len; i++) {\n    var charCode = url.charCodeAt(i); // Some systems do not follow RFC and separate the path and query\n    // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.\n    // Thus, we need to split on `;` as well as `?` and `#`.\n\n    if (charCode === 63 || charCode === 59 || charCode === 35) {\n      return url.slice(0, i);\n    }\n  }\n\n  return url;\n}\n\nfunction getWildcardNode(node, method, path, len) {\n  if (node === null) return null;\n  var decoded = fastDecode(path.slice(-len));\n  if (decoded === null) return null;\n  var handle = node.handlers[method];\n\n  if (handle !== null && handle !== undefined) {\n    return {\n      handler: handle.handler,\n      params: {\n        '*': decoded\n      },\n      store: handle.store\n    };\n  }\n\n  return null;\n}\n\nfunction getClosingParenthensePosition(path, idx) {\n  // `path.indexOf()` will always return the first position of the closing parenthese,\n  // but it's inefficient for grouped or wrong regexp expressions.\n  // see issues #62 and #63 for more info\n  var parentheses = 1;\n\n  while (idx < path.length) {\n    idx++; // ignore skipped chars\n\n    if (path[idx] === '\\\\') {\n      idx++;\n      continue;\n    }\n\n    if (path[idx] === ')') {\n      parentheses--;\n    } else if (path[idx] === '(') {\n      parentheses++;\n    }\n\n    if (!parentheses) return idx;\n  }\n\n  throw new TypeError('Invalid regexp expression in \"' + path + '\"');\n}","map":null,"metadata":{},"sourceType":"script"}