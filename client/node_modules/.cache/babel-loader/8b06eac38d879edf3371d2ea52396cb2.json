{"ast":null,"code":"// Copyright (c) 2013, Joyent, Inc. All rights reserved.\n'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar assert = require('assert-plus');\n/**\n * An custom error for capturing an invalid upgrade state.\n *\n * @public\n * @class\n * @param {String} msg - an error message\n */\n\n\nfunction InvalidUpgradeStateError(msg) {\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, InvalidUpgradeStateError);\n  }\n\n  this.message = msg;\n  this.name = 'InvalidUpgradeStateError';\n}\n\nutil.inherits(InvalidUpgradeStateError, Error); //\n// The Node HTTP Server will, if we handle the 'upgrade' event, swallow any\n// Request with the 'Connection: upgrade' header set.  While doing this it\n// detaches from the 'data' events on the Socket and passes the socket to\n// us, so that we may take over handling for the connection.\n//\n// Unfortunately, the API does not presently provide a http.ServerResponse\n// for us to use in the event that we do not wish to upgrade the connection.\n// This factory method provides a skeletal implementation of a\n// restify-compatible response that is sufficient to allow the existing\n// request handling path to work, while allowing us to perform _at most_ one\n// of either:\n//\n//   - Return a basic HTTP Response with a provided Status Code and\n//     close the socket.\n//   - Upgrade the connection and stop further processing.\n//\n// To determine if an upgrade is requested, a route handler would check for\n// the 'claimUpgrade' method on the Response.  The object this method\n// returns will have the 'socket' and 'head' Buffer emitted with the\n// 'upgrade' event by the http.Server.  If the upgrade is not possible, such\n// as when the HTTP head (or a full request) has already been sent by some\n// other handler, this method will throw.\n//\n\n/**\n * Create a new upgraded response.\n *\n * @public\n * @function createServerUpgradeResponse\n * @param    {Object} req -    the request object\n * @param    {Object} socket - the network socket\n * @param    {Object} head -   a buffer, the first packet of the upgraded stream\n * @returns  {Object}        an upgraded reponses\n */\n\nfunction createServerUpgradeResponse(req, socket, head) {\n  return new ServerUpgradeResponse(socket, head);\n}\n/**\n * Upgrade the http response\n *\n * @private\n * @class\n * @param   {Object}    socket - the network socket\n * @param   {Object}    head -   a buffer, the first packet of\n *                               the upgraded stream\n * @returns {undefined} no return value\n */\n\n\nfunction ServerUpgradeResponse(socket, head) {\n  assert.object(socket, 'socket');\n  assert.buffer(head, 'head');\n  EventEmitter.call(this);\n  this.sendDate = true;\n  this.statusCode = 400;\n  this._upgrade = {\n    socket: socket,\n    head: head\n  };\n  this._headWritten = false;\n  this._upgradeClaimed = false;\n}\n\nutil.inherits(ServerUpgradeResponse, EventEmitter);\n/**\n * A function generator for all programatically attaching methods on to\n * the ServerUpgradeResponse class.\n *\n * @private\n * @function notImplemented\n * @param    {Object}   method - an object containing configuration\n * @returns  {Function} function\n */\n\nfunction notImplemented(method) {\n  if (!method.throws) {\n    return function returns() {\n      return method.returns;\n    };\n  } else {\n    return function throws() {\n      throw new Error('Method ' + method.name + ' is not implemented!');\n    };\n  }\n}\n\nvar NOT_IMPLEMENTED = [{\n  name: 'writeContinue',\n  throws: true\n}, {\n  name: 'setHeader',\n  throws: false,\n  returns: null\n}, {\n  name: 'getHeader',\n  throws: false,\n  returns: null\n}, {\n  name: 'getHeaders',\n  throws: false,\n  returns: {}\n}, {\n  name: 'removeHeader',\n  throws: false,\n  returns: null\n}, {\n  name: 'addTrailer',\n  throws: false,\n  returns: null\n}, {\n  name: 'cache',\n  throws: false,\n  returns: 'public'\n}, {\n  name: 'format',\n  throws: true\n}, {\n  name: 'set',\n  throws: false,\n  returns: null\n}, {\n  name: 'get',\n  throws: false,\n  returns: null\n}, {\n  name: 'headers',\n  throws: false,\n  returns: {}\n}, {\n  name: 'header',\n  throws: false,\n  returns: null\n}, {\n  name: 'json',\n  throws: false,\n  returns: null\n}, {\n  name: 'link',\n  throws: false,\n  returns: null\n}]; // programatically add a bunch of methods to the ServerUpgradeResponse proto\n\nNOT_IMPLEMENTED.forEach(function forEach(method) {\n  ServerUpgradeResponse.prototype[method.name] = notImplemented(method);\n});\n/**\n * Internal implementation of `writeHead`\n *\n * @private\n * @function _writeHeadImpl\n * @param   {Number} statusCode - the http status code\n * @param   {String} reason -     a message\n * @returns {undefined} no return value\n */\n\nServerUpgradeResponse.prototype._writeHeadImpl = function _writeHeadImpl(statusCode, reason) {\n  if (this._headWritten) {\n    return;\n  }\n\n  this._headWritten = true;\n\n  if (this._upgradeClaimed) {\n    throw new InvalidUpgradeStateError('Upgrade already claimed!');\n  }\n\n  var head = ['HTTP/1.1 ' + statusCode + ' ' + reason, 'Connection: close'];\n\n  if (this.sendDate) {\n    head.push('Date: ' + new Date().toUTCString());\n  }\n\n  this._upgrade.socket.write(head.join('\\r\\n') + '\\r\\n');\n};\n/**\n * Set the status code of the response.\n *\n * @public\n * @function  status\n * @param     {Number} code - the http status code\n * @returns   {undefined} no return value\n */\n\n\nServerUpgradeResponse.prototype.status = function status(code) {\n  assert.number(code, 'code');\n  this.statusCode = code;\n  return code;\n};\n/**\n * Sends the response.\n *\n * @public\n * @function  send\n * @param     {Number}           code - the http status code\n * @param     {Object | String}  body - the response to send out\n * @returns   {undefined} no return value\n */\n\n\nServerUpgradeResponse.prototype.send = function send(code, body) {\n  if (typeof code === 'number') {\n    this.statusCode = code;\n  } else {\n    body = code;\n  }\n\n  if (typeof body === 'object') {\n    if (typeof body.statusCode === 'number') {\n      this.statusCode = body.statusCode;\n    }\n\n    if (typeof body.message === 'string') {\n      this.statusReason = body.message;\n    }\n  }\n\n  return this.end();\n};\n/**\n * End the response.\n *\n * @public\n * @function end\n * @returns  {Boolean} always returns true\n */\n\n\nServerUpgradeResponse.prototype.end = function end() {\n  this._writeHeadImpl(this.statusCode, 'Connection Not Upgraded');\n\n  this._upgrade.socket.end('\\r\\n');\n\n  return true;\n};\n/**\n * Write to the response.\n *\n * @public\n * @function write\n * @returns  {Boolean} always returns true\n */\n\n\nServerUpgradeResponse.prototype.write = function write() {\n  this._writeHeadImpl(this.statusCode, 'Connection Not Upgraded');\n\n  return true;\n};\n/**\n * Write to the head of the response.\n *\n * @public\n * @function writeHead\n * @param   {Number} statusCode - the http status code\n * @param   {String} reason -     a message\n * @returns {undefined} no return value\n */\n\n\nServerUpgradeResponse.prototype.writeHead = function writeHead(statusCode, reason) {\n  assert.number(statusCode, 'statusCode');\n  assert.optionalString(reason, 'reason');\n  this.statusCode = statusCode;\n\n  if (!reason) {\n    reason = 'Connection Not Upgraded';\n  }\n\n  if (this._headWritten) {\n    throw new Error('Head already written!');\n  }\n\n  return this._writeHeadImpl(statusCode, reason);\n};\n/**\n * Attempt to upgrade.\n *\n * @public\n * @function claimUpgrade\n * @returns  {Object}     an object containing the socket and head\n */\n\n\nServerUpgradeResponse.prototype.claimUpgrade = function claimUpgrade() {\n  if (this._upgradeClaimed) {\n    throw new InvalidUpgradeStateError('Upgrade already claimed!');\n  }\n\n  if (this._headWritten) {\n    throw new InvalidUpgradeStateError('Upgrade already aborted!');\n  }\n\n  this._upgradeClaimed = true;\n  return this._upgrade;\n};\n\nmodule.exports = {\n  createResponse: createServerUpgradeResponse,\n  InvalidUpgradeStateError: InvalidUpgradeStateError\n};","map":null,"metadata":{},"sourceType":"script"}