{"ast":null,"code":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n'use strict';\n\nvar Stream = require('stream').Stream;\n\nvar util = require('util');\n\nvar assert = require('assert-plus');\n\nvar bunyan = require('bunyan');\n\nvar LRU = require('lru-cache');\n\nvar uuid = require('uuid'); ///--- Globals\n\n\nvar sprintf = util.format;\nvar DEFAULT_REQ_ID = uuid.v4();\nvar STR_FMT = '[object %s<level=%d, limit=%d, maxRequestIds=%d>]'; ///--- Helpers\n\n/**\n * Appends streams\n *\n * @private\n * @function appendStream\n * @param    {Stream}    streams - the stream to append to\n * @param    {Stream}    s       - the stream to append\n * @returns  {undefined} no return value\n */\n\nfunction appendStream(streams, s) {\n  assert.arrayOfObject(streams, 'streams');\n  assert.object(s, 'stream');\n\n  if (s instanceof Stream) {\n    streams.push({\n      raw: false,\n      stream: s\n    });\n  } else {\n    assert.optionalBool(s.raw, 'stream.raw');\n    assert.object(s.stream, 'stream.stream');\n    streams.push(s);\n  }\n} ///--- API\n\n/**\n * A Bunyan stream to capture records in a ring buffer and only pass through\n * on a higher-level record. E.g. buffer up all records but only dump when\n * getting a WARN or above.\n *\n * @public\n * @class\n * @param {Object} opts -                contains the parameters:\n * @param {Object} opts.stream -         The stream to which to write when\n *                                       dumping captured records.\n *                                       One of `stream`\n *                                       or `streams` must be specified.\n * @param {Array} opts.streams -         One of `stream` or `streams` must be\n *                                       specified.\n * @param {Number | String} opts.level - The level at which to trigger dumping\n *                                       captured records. Defaults to\n *                                       bunyan.WARN.\n * @param {Number} opts.maxRecords -     Number of records to capture. Default\n *                                       100.\n * @param {Number} opts.maxRequestIds -  Number of simultaneous request id\n *                                       capturing buckets to maintain. Default\n *                                       1000.\n * @param {Boolean} opts.dumpDefault -   If true, then dump captured records on\n *                                       the *default* request id when dumping.\n *                                       I.e. dump records logged without\n *                                       \"req_id\" field. Default false.\n */\n\n\nfunction RequestCaptureStream(opts) {\n  assert.object(opts, 'options');\n  assert.optionalObject(opts.stream, 'options.stream');\n  assert.optionalArrayOfObject(opts.streams, 'options.streams');\n  assert.optionalNumber(opts.level, 'options.level');\n  assert.optionalNumber(opts.maxRecords, 'options.maxRecords');\n  assert.optionalNumber(opts.maxRequestIds, 'options.maxRequestIds');\n  assert.optionalBool(opts.dumpDefault, 'options.dumpDefault');\n  var self = this;\n  Stream.call(this);\n  this.level = opts.level ? bunyan.resolveLevel(opts.level) : bunyan.WARN;\n  this.limit = opts.maxRecords || 100;\n  this.maxRequestIds = opts.maxRequestIds || 1000; // eslint-disable-next-line new-cap\n  // need to initialize using `new`\n\n  this.requestMap = new LRU({\n    max: self.maxRequestIds\n  });\n  this.dumpDefault = opts.dumpDefault;\n  this._offset = -1;\n  this._rings = [];\n  this.streams = [];\n\n  if (opts.stream) {\n    appendStream(this.streams, opts.stream);\n  }\n\n  if (opts.streams) {\n    opts.streams.forEach(appendStream.bind(null, this.streams));\n  }\n\n  this.haveNonRawStreams = false;\n\n  for (var i = 0; i < this.streams.length; i++) {\n    if (!this.streams[i].raw) {\n      this.haveNonRawStreams = true;\n      break;\n    }\n  }\n}\n\nutil.inherits(RequestCaptureStream, Stream);\n/**\n * Write to the stream\n *\n * @public\n * @function write\n * @param    {Object}    record - a bunyan log record\n * @returns  {undefined} no return value\n */\n\nRequestCaptureStream.prototype.write = function write(record) {\n  var req_id = record.req_id || DEFAULT_REQ_ID;\n  var ring;\n  var self = this;\n\n  if (!(ring = this.requestMap.get(req_id))) {\n    if (++this._offset > this.maxRequestIds) {\n      this._offset = 0;\n    }\n\n    if (this._rings.length <= this._offset) {\n      this._rings.push(new bunyan.RingBuffer({\n        limit: self.limit\n      }));\n    }\n\n    ring = this._rings[this._offset];\n    ring.records.length = 0;\n    this.requestMap.set(req_id, ring);\n  }\n\n  assert.ok(ring, 'no ring found'); // write the record to the ring.\n\n  ring.write(record); // triger dumping of all the records\n\n  if (record.level >= this.level) {\n    var i, r, ser;\n\n    for (i = 0; i < ring.records.length; i++) {\n      r = ring.records[i];\n\n      if (this.haveNonRawStreams) {\n        ser = JSON.stringify(r, bunyan.safeCycles()) + '\\n';\n      }\n\n      self.streams.forEach(function forEach(s) {\n        s.stream.write(s.raw ? r : ser);\n      });\n    }\n\n    ring.records.length = 0;\n\n    if (this.dumpDefault) {\n      var defaultRing = self.requestMap.get(DEFAULT_REQ_ID);\n\n      for (i = 0; i < defaultRing.records.length; i++) {\n        r = defaultRing.records[i];\n\n        if (this.haveNonRawStreams) {\n          ser = JSON.stringify(r, bunyan.safeCycles()) + '\\n';\n        }\n\n        self.streams.forEach(function forEach(s) {\n          s.stream.write(s.raw ? r : ser);\n        });\n      }\n\n      defaultRing.records.length = 0;\n    }\n  }\n};\n/**\n * toString() serialization\n *\n * @public\n * @function toString\n * @returns  {String} stringified instance\n */\n\n\nRequestCaptureStream.prototype.toString = function toString() {\n  return sprintf(STR_FMT, this.constructor.name, this.level, this.limit, this.maxRequestIds);\n}; ///--- Serializers\n\n\nvar SERIALIZERS = {\n  err: bunyan.stdSerializers.err,\n  req: bunyan.stdSerializers.req,\n  res: bunyan.stdSerializers.res,\n  client_req: clientReq,\n  client_res: clientRes\n};\n/**\n * A request serializer. returns a stripped down object for logging.\n *\n * @private\n * @function clientReq\n * @param    {Object} req - the request object\n * @returns  {Object} serialized req\n */\n\nfunction clientReq(req) {\n  if (!req) {\n    return req;\n  }\n\n  var host;\n\n  try {\n    host = req.host.split(':')[0];\n  } catch (e) {\n    host = false;\n  }\n\n  return {\n    method: req ? req.method : false,\n    url: req ? req.path : false,\n    address: host,\n    port: req ? req.port : false,\n    headers: req ? req.headers : false\n  };\n}\n/**\n * A response serializer. returns a stripped down object for logging.\n *\n * @private\n * @function clientRes\n * @param    {Object} res - the response object\n * @returns  {Object} serialized response\n */\n\n\nfunction clientRes(res) {\n  if (!res || !res.statusCode) {\n    return res;\n  }\n\n  return {\n    statusCode: res.statusCode,\n    headers: res.headers\n  };\n}\n/**\n * Create a bunyan logger.\n *\n * @public\n * @function createLogger\n * @param    {String}     name - of the logger\n * @returns  {Object}          bunyan logger\n */\n\n\nfunction createLogger(name) {\n  return bunyan.createLogger({\n    name: name,\n    serializers: SERIALIZERS,\n    streams: [{\n      level: 'warn',\n      stream: process.stderr\n    }, {\n      level: 'debug',\n      type: 'raw',\n      stream: new RequestCaptureStream({\n        stream: process.stderr\n      })\n    }]\n  });\n} ///--- Exports\n\n\nmodule.exports = {\n  RequestCaptureStream: RequestCaptureStream,\n  serializers: SERIALIZERS,\n  createLogger: createLogger\n};","map":null,"metadata":{},"sourceType":"script"}