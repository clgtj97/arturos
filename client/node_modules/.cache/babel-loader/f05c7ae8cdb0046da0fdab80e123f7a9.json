{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar http = require('http');\n\nvar _ = require('lodash');\n\nvar assert = require('assert-plus');\n\nvar errors = require('restify-errors');\n\nvar uuid = require('uuid');\n\nvar Chain = require('./chain');\n\nvar RouterRegistryRadix = require('./routerRegistryRadix'); ///--- Globals\n\n\nvar MethodNotAllowedError = errors.MethodNotAllowedError;\nvar ResourceNotFoundError = errors.ResourceNotFoundError; ///--- API\n\n/**\n * Router class handles mapping of http verbs and a regexp path,\n * to an array of handler functions.\n *\n * @class\n * @public\n * @param  {Object} options - an options object\n * @param  {Bunyan} options.log - Bunyan logger instance\n * @param {Boolean} [options.onceNext=false] - Prevents calling next multiple\n *  times\n * @param {Boolean} [options.strictNext=false] - Throws error when next() is\n *  called more than once, enabled onceNext option\n * @param {Object} [options.registry] - route registry\n * @param {Boolean} [options.ignoreTrailingSlash=false] - ignore trailing slash\n * on paths\n */\n\nfunction Router(options) {\n  assert.object(options, 'options');\n  assert.object(options.log, 'options.log');\n  assert.optionalBool(options.onceNext, 'options.onceNext');\n  assert.optionalBool(options.strictNext, 'options.strictNext');\n  assert.optionalBool(options.ignoreTrailingSlash, 'options.ignoreTrailingSlash');\n  EventEmitter.call(this);\n  this.log = options.log;\n  this.onceNext = !!options.onceNext;\n  this.strictNext = !!options.strictNext;\n  this.name = 'RestifyRouter'; // Internals\n\n  this._anonymousHandlerCounter = 0;\n  this._registry = options.registry || new RouterRegistryRadix(options);\n}\n\nutil.inherits(Router, EventEmitter);\n/**\n * Lookup for route\n *\n * @public\n * @memberof Router\n * @instance\n * @function lookup\n * @param  {Request} req - request\n * @param  {Response} res - response\n * @returns {Chain|undefined} handler or undefined\n */\n\nRouter.prototype.lookup = function lookup(req, res) {\n  var pathname = req.getUrl().pathname; // Find route\n\n  var registryRoute = this._registry.lookup(req.method, pathname); // Not found\n\n\n  if (!registryRoute) {\n    return undefined;\n  } // Decorate req\n\n\n  req.params = Object.assign(req.params, registryRoute.params);\n  req.route = registryRoute.route; // Call handler chain\n\n  return registryRoute.handler;\n};\n/**\n * Lookup by name\n *\n * @public\n * @memberof Router\n * @instance\n * @function lookupByName\n * @param {String} name - route name\n * @param  {Request} req - request\n * @param  {Response} res - response\n * @returns {Chain|undefined} handler or undefined\n */\n\n\nRouter.prototype.lookupByName = function lookupByName(name, req, res) {\n  var self = this;\n\n  var route = self._registry.get()[name];\n\n  if (!route) {\n    return undefined;\n  } // Decorate req\n\n\n  req.route = route;\n  return route.chain.run.bind(route.chain);\n};\n/**\n * Takes an object of route params and query params, and 'renders' a URL.\n *\n * @public\n * @function render\n * @param    {String} routeName - the route name\n * @param    {Object} params -    an object of route params\n * @param    {Object} query -     an object of query params\n * @returns  {String} URL\n * @example\n * server.get({\n *      name: 'cities',\n *      path: '/countries/:name/states/:state/cities'\n * }, (req, res, next) => ...));\n * let cities = server.router.render('cities', {\n *      name: 'Australia',\n *      state: 'New South Wales'\n * });\n * // cities:  '/countries/Australia/states/New%20South%20Wales/cities'\n */\n\n\nRouter.prototype.render = function render(routeName, params, query) {\n  var self = this;\n\n  function pathItem(match, key) {\n    if (params.hasOwnProperty(key) === false) {\n      throw new Error('Route <' + routeName + '> is missing parameter <' + key + '>');\n    }\n\n    return '/' + encodeURIComponent(params[key]);\n  }\n\n  function queryItem(key) {\n    return encodeURIComponent(key) + '=' + encodeURIComponent(query[key]);\n  }\n\n  var route = self._registry.get()[routeName];\n\n  if (!route) {\n    return null;\n  }\n\n  var _path = route.spec.path;\n\n  var _url = _path.replace(/\\/:([A-Za-z0-9_]+)(\\([^\\\\]+?\\))?/g, pathItem);\n\n  var items = Object.keys(query || {}).map(queryItem);\n  var queryString = items.length > 0 ? '?' + items.join('&') : '';\n  return _url + queryString;\n};\n/**\n * Adds a route.\n *\n * @public\n * @memberof Router\n * @instance\n * @function mount\n * @param    {Object} opts - an options object\n * @param    {String} opts.name - name\n * @param    {String} opts.method - method\n * @param    {String} opts.path - path can be any String\n * @param    {Function[]} handlers - handlers\n * @returns  {String} returns the route name if creation is successful.\n * @fires ...String#mount\n */\n\n\nRouter.prototype.mount = function mount(opts, handlers) {\n  var self = this;\n  assert.object(opts, 'opts');\n  assert.string(opts.method, 'opts.method');\n  assert.arrayOfFunc(handlers, 'handlers');\n  assert.optionalString(opts.name, 'opts.name');\n  var chain = new Chain({\n    onceNext: self.onceNext,\n    strictNext: self.strictNext\n  }); // Route\n\n  var route = {\n    name: self._getRouteName(opts.name, opts.method, opts.path),\n    method: opts.method,\n    path: opts.path,\n    spec: opts,\n    chain: chain\n  };\n  handlers.forEach(function forEach(handler) {\n    // Assign name to anonymous functions\n    handler._name = handler.name || 'handler-' + self._anonymousHandlerCounter++; // Attach to middleware chain\n\n    chain.add(handler);\n  });\n\n  self._registry.add(route);\n\n  self.emit('mount', route.method, route.path);\n  return route;\n};\n/**\n * Unmounts a route.\n *\n * @public\n * @memberof Router\n * @instance\n * @function unmount\n * @param    {String} name - the route name\n * @returns  {Object|undefined} removed route if found\n */\n\n\nRouter.prototype.unmount = function unmount(name) {\n  assert.string(name, 'name');\n\n  var route = this._registry.remove(name);\n\n  return route;\n};\n/**\n * toString() serialization.\n *\n * @public\n * @memberof Router\n * @instance\n * @function toString\n * @returns  {String} stringified router\n */\n\n\nRouter.prototype.toString = function toString() {\n  return this._registry.toString();\n};\n/**\n * Return information about the routes registered in the router.\n *\n * @public\n * @memberof Router\n * @instance\n * @returns {object} The routes in the router.\n */\n\n\nRouter.prototype.getDebugInfo = function getDebugInfo() {\n  var routes = this._registry.get();\n\n  return _.mapValues(routes, function mapValues(route, routeName) {\n    return {\n      name: route.name,\n      method: route.method.toLowerCase(),\n      path: route.path,\n      handlers: route.chain.getHandlers()\n    };\n  });\n};\n/**\n * Return mounted routes\n *\n * @public\n * @memberof Router\n * @instance\n * @returns {object} The routes in the router.\n */\n\n\nRouter.prototype.getRoutes = function getRoutes() {\n  return this._registry.get();\n};\n/**\n * Returns true if the router generated a 404 for an options request.\n *\n * TODO: this is relevant for CORS only. Should move this out eventually to a\n * userland middleware? This also seems a little like overreach, as there is no\n * option to opt out of this behavior today.\n *\n * @private\n * @static\n * @function _optionsError\n * @param    {Object}     req - the request object\n * @param    {Object}     res - the response object\n * @returns  {Boolean} is options error\n */\n\n\nRouter._optionsError = function _optionsError(req, res) {\n  var pathname = req.getUrl().pathname;\n  return req.method === 'OPTIONS' && pathname === '*';\n};\n/**\n * Default route, when no route found\n * Responds with a ResourceNotFoundError error.\n *\n * @private\n * @memberof Router\n * @instance\n * @function defaultRoute\n * @param  {Request} req - request\n * @param  {Response} res - response\n * @param  {Function} next - next\n * @returns {undefined} no return value\n */\n\n\nRouter.prototype.defaultRoute = function defaultRoute(req, res, next) {\n  var self = this;\n  var pathname = req.getUrl().pathname; // Allow CORS\n\n  if (Router._optionsError(req, res, pathname)) {\n    res.send(200);\n    next(null, req, res);\n    return;\n  } // Check for 405 instead of 404\n\n\n  var allowedMethods = http.METHODS.filter(function some(method) {\n    return method !== req.method && self._registry.lookup(method, pathname);\n  });\n\n  if (allowedMethods.length) {\n    res.methods = allowedMethods;\n    res.setHeader('Allow', allowedMethods.join(', '));\n    var methodErr = new MethodNotAllowedError('%s is not allowed', req.method);\n    next(methodErr, req, res);\n    return;\n  } // clean up the url in case of potential xss\n  // https://github.com/restify/node-restify/issues/1018\n\n\n  var err = new ResourceNotFoundError('%s does not exist', pathname);\n  next(err, req, res);\n};\n/**\n * Generate route name\n *\n * @private\n * @memberof Router\n * @instance\n * @function _getRouteName\n * @param    {String|undefined} name - Name of the route\n * @param    {String} method - HTTP method\n * @param    {String} path - path\n * @returns  {String} name of the route\n */\n\n\nRouter.prototype._getRouteName = function _getRouteName(name, method, path) {\n  // Generate name\n  if (!name) {\n    name = method + '-' + path;\n    name = name.replace(/\\W/g, '').toLowerCase();\n  } // Avoid name conflict: GH-401\n\n\n  if (this._registry.get()[name]) {\n    name += uuid.v4().substr(0, 7);\n  }\n\n  return name;\n};\n\nmodule.exports = Router;","map":null,"metadata":{},"sourceType":"script"}