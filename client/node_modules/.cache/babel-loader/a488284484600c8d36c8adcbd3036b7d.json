{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar https = require('https');\n\nvar http = require('http');\n\nvar tls = require('tls');\n\nvar net = require('net');\n\nvar util = require('util');\n\nvar selectHose = require('select-hose');\n\nvar transport = require('spdy-transport');\n\nvar debug = require('debug')('spdy:server');\n\nvar EventEmitter = require('events').EventEmitter; // Node.js 0.8, 0.10 and 0.12 support\n\n\nObject.assign = process.versions.modules >= 46 ? Object.assign // eslint-disable-next-line\n: util._extend;\n\nvar spdy = require('../spdy');\n\nvar proto = {};\n\nfunction instantiate(base) {\n  function Server(options, handler) {\n    this._init(base, options, handler);\n  }\n\n  util.inherits(Server, base);\n\n  Server.create = function create(options, handler) {\n    return new Server(options, handler);\n  };\n\n  Object.keys(proto).forEach(function (key) {\n    Server.prototype[key] = proto[key];\n  });\n  return Server;\n}\n\nproto._init = function _init(base, options, handler) {\n  var state = {};\n  this._spdyState = state;\n  state.options = options.spdy || {};\n  var protocols = state.options.protocols || ['h2', 'spdy/3.1', 'spdy/3', 'spdy/2', 'http/1.1', 'http/1.0'];\n  var actualOptions = Object.assign({\n    NPNProtocols: protocols,\n    // Future-proof\n    ALPNProtocols: protocols\n  }, options);\n  state.secure = this instanceof tls.Server;\n\n  if (state.secure) {\n    base.call(this, actualOptions);\n  } else {\n    base.call(this);\n  } // Support HEADERS+FIN\n\n\n  this.httpAllowHalfOpen = true;\n  var event = state.secure ? 'secureConnection' : 'connection';\n  state.listeners = this.listeners(event).slice();\n  assert(state.listeners.length > 0, 'Server does not have default listeners');\n  this.removeAllListeners(event);\n\n  if (state.options.plain) {\n    this.on(event, this._onPlainConnection);\n  } else {\n    this.on(event, this._onConnection);\n  }\n\n  if (handler) {\n    this.on('request', handler);\n  }\n\n  debug('server init secure=%d', state.secure);\n};\n\nproto._onConnection = function _onConnection(socket) {\n  var state = this._spdyState;\n  var protocol;\n\n  if (state.secure) {\n    protocol = socket.npnProtocol || socket.alpnProtocol;\n  }\n\n  this._handleConnection(socket, protocol);\n};\n\nproto._handleConnection = function _handleConnection(socket, protocol) {\n  var state = this._spdyState;\n\n  if (!protocol) {\n    protocol = state.options.protocol;\n  }\n\n  debug('incoming socket protocol=%j', protocol); // No way we can do anything with the socket\n\n  if (!protocol || protocol === 'http/1.1' || protocol === 'http/1.0') {\n    debug('to default handler it goes');\n    return this._invokeDefault(socket);\n  }\n\n  socket.setNoDelay(true);\n  var connection = transport.connection.create(socket, Object.assign({\n    protocol: /spdy/.test(protocol) ? 'spdy' : 'http2',\n    isServer: true\n  }, state.options.connection || {})); // Set version when we are certain\n\n  if (protocol === 'http2') {\n    connection.start(4);\n  } else if (protocol === 'spdy/3.1') {\n    connection.start(3.1);\n  } else if (protocol === 'spdy/3') {\n    connection.start(3);\n  } else if (protocol === 'spdy/2') {\n    connection.start(2);\n  }\n\n  connection.on('error', function () {\n    socket.destroy();\n  });\n  var self = this;\n  connection.on('stream', function (stream) {\n    self._onStream(stream);\n  });\n}; // HTTP2 preface\n\n\nvar PREFACE = 'PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n';\nvar PREFACE_BUFFER = Buffer.from(PREFACE);\n\nfunction hoseFilter(data, callback) {\n  if (data.length < 1) {\n    return callback(null, null);\n  } // SPDY!\n\n\n  if (data[0] === 0x80) {\n    return callback(null, 'spdy');\n  }\n\n  var avail = Math.min(data.length, PREFACE_BUFFER.length);\n\n  for (var i = 0; i < avail; i++) {\n    if (data[i] !== PREFACE_BUFFER[i]) {\n      return callback(null, 'http/1.1');\n    }\n  } // Not enough bytes to be sure about HTTP2\n\n\n  if (avail !== PREFACE_BUFFER.length) {\n    return callback(null, null);\n  }\n\n  return callback(null, 'h2');\n}\n\nproto._onPlainConnection = function _onPlainConnection(socket) {\n  var hose = selectHose.create(socket, {}, hoseFilter);\n  var self = this;\n  hose.on('select', function (protocol, socket) {\n    self._handleConnection(socket, protocol);\n  });\n  hose.on('error', function (err) {\n    debug('hose error %j', err.message);\n    socket.destroy();\n  });\n};\n\nproto._invokeDefault = function _invokeDefault(socket) {\n  var state = this._spdyState;\n\n  for (var i = 0; i < state.listeners.length; i++) {\n    state.listeners[i].call(this, socket);\n  }\n};\n\nproto._onStream = function _onStream(stream) {\n  var state = this._spdyState;\n  var handle = spdy.handle.create(this._spdyState.options, stream);\n  var socketOptions = {\n    handle: handle,\n    allowHalfOpen: true\n  };\n  var socket;\n\n  if (state.secure) {\n    socket = new spdy.Socket(stream.connection.socket, socketOptions);\n  } else {\n    socket = new net.Socket(socketOptions);\n  } // This is needed because the `error` listener, added by the default\n  // `connection` listener, no longer has bound arguments. It relies instead\n  // on the `server` property of the socket. See https://github.com/nodejs/node/pull/11926\n  // for more details.\n  // This is only done for Node.js >= 4 in order to not break compatibility\n  // with older versions of the platform.\n\n\n  if (process.versions.modules >= 46) {\n    socket.server = this;\n  }\n\n  handle.assignSocket(socket); // For v0.8\n\n  socket.readable = true;\n  socket.writable = true;\n\n  this._invokeDefault(socket); // For v0.8, 0.10 and 0.12\n\n\n  if (process.versions.modules < 46) {\n    // eslint-disable-next-line\n    this.listenerCount = EventEmitter.listenerCount.bind(this);\n  } // Add lazy `checkContinue` listener, otherwise `res.writeContinue` will be\n  // called before the response object was patched by us.\n\n\n  if (stream.headers.expect !== undefined && /100-continue/i.test(stream.headers.expect) && this.listenerCount('checkContinue') === 0) {\n    this.once('checkContinue', function (req, res) {\n      res.writeContinue();\n      this.emit('request', req, res);\n    });\n  }\n\n  handle.emitRequest();\n};\n\nproto.emit = function emit(event, req, res) {\n  if (event !== 'request' && event !== 'checkContinue') {\n    return EventEmitter.prototype.emit.apply(this, arguments);\n  }\n\n  if (!(req.socket._handle instanceof spdy.handle)) {\n    debug('not spdy req/res');\n    req.isSpdy = false;\n    req.spdyVersion = 1;\n    res.isSpdy = false;\n    res.spdyVersion = 1;\n    return EventEmitter.prototype.emit.apply(this, arguments);\n  }\n\n  var handle = req.connection._handle;\n  req.isSpdy = true;\n  req.spdyVersion = handle.getStream().connection.getVersion();\n  res.isSpdy = true;\n  res.spdyVersion = req.spdyVersion;\n  req.spdyStream = handle.getStream();\n  debug('override req/res');\n  res.writeHead = spdy.response.writeHead;\n  res.end = spdy.response.end;\n  res.push = spdy.response.push;\n  res.writeContinue = spdy.response.writeContinue;\n  res.spdyStream = handle.getStream();\n  res._req = req;\n  handle.assignRequest(req);\n  handle.assignResponse(res);\n  return EventEmitter.prototype.emit.apply(this, arguments);\n};\n\nexports.Server = instantiate(https.Server);\nexports.PlainServer = instantiate(http.Server);\n\nexports.create = function create(base, options, handler) {\n  if (typeof base === 'object') {\n    handler = options;\n    options = base;\n    base = null;\n  }\n\n  if (base) {\n    return instantiate(base).create(options, handler);\n  }\n\n  if (options.spdy && options.spdy.plain) {\n    return exports.PlainServer.create(options, handler);\n  } else {\n    return exports.Server.create(options, handler);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}