{"ast":null,"code":"/**\n * Copyright (c) 2017 Trent Mick.\n * Copyright (c) 2017 Joyent Inc.\n *\n * The bunyan logging library for node.js.\n *\n * -*- mode: js -*-\n * vim: expandtab:ts=4:sw=4\n */\nvar VERSION = '1.8.12';\n/*\n * Bunyan log format version. This becomes the 'v' field on all log records.\n * This will be incremented if there is any backward incompatible change to\n * the log record format. Details will be in 'CHANGES.md' (the change log).\n */\n\nvar LOG_VERSION = 0;\n\nvar xxx = function xxx(s) {\n  // internal dev/debug logging\n  var args = ['XX' + 'X: ' + s].concat(Array.prototype.slice.call(arguments, 1));\n  console.error.apply(this, args);\n};\n\nvar xxx = function xxx() {}; // comment out to turn on debug logging\n\n/*\n * Runtime environment notes:\n *\n * Bunyan is intended to run in a number of runtime environments. Here are\n * some notes on differences for those envs and how the code copes.\n *\n * - node.js: The primary target environment.\n * - NW.js: http://nwjs.io/  An *app* environment that feels like both a\n *   node env -- it has node-like globals (`process`, `global`) and\n *   browser-like globals (`window`, `navigator`). My *understanding* is that\n *   bunyan can operate as if this is vanilla node.js.\n * - browser: Failing the above, we sniff using the `window` global\n *   <https://developer.mozilla.org/en-US/docs/Web/API/Window/window>.\n *      - browserify: http://browserify.org/  A browser-targetting bundler of\n *        node.js deps. The runtime is a browser env, so can't use fs access,\n *        etc. Browserify's build looks for `require(<single-string>)` imports\n *        to bundle. For some imports it won't be able to handle, we \"hide\"\n *        from browserify with `require('frobshizzle' + '')`.\n * - Other? Please open issues if things are broken.\n */\n\n\nvar runtimeEnv;\n\nif (typeof process !== 'undefined' && process.versions) {\n  if (process.versions.nw) {\n    runtimeEnv = 'nw';\n  } else if (process.versions.node) {\n    runtimeEnv = 'node';\n  }\n}\n\nif (!runtimeEnv && typeof window !== 'undefined' && window.window === window) {\n  runtimeEnv = 'browser';\n}\n\nif (!runtimeEnv) {\n  throw new Error('unknown runtime environment');\n}\n\nvar os, fs, dtrace;\n\nif (runtimeEnv === 'browser') {\n  os = {\n    hostname: function hostname() {\n      return window.location.host;\n    }\n  };\n  fs = {};\n  dtrace = null;\n} else {\n  os = require('os');\n  fs = require('fs');\n\n  try {\n    dtrace = require('dtrace-provider' + '');\n  } catch (e) {\n    dtrace = null;\n  }\n}\n\nvar util = require('util');\n\nvar assert = require('assert');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar stream = require('stream');\n\ntry {\n  var safeJsonStringify = require('safe-json-stringify');\n} catch (e) {\n  safeJsonStringify = null;\n}\n\nif (process.env.BUNYAN_TEST_NO_SAFE_JSON_STRINGIFY) {\n  safeJsonStringify = null;\n} // The 'mv' module is required for rotating-file stream support.\n\n\ntry {\n  var mv = require('mv' + '');\n} catch (e) {\n  mv = null;\n}\n\ntry {\n  var sourceMapSupport = require('source-map-support' + '');\n} catch (_) {\n  sourceMapSupport = null;\n} //---- Internal support stuff\n\n/**\n * A shallow copy of an object. Bunyan logging attempts to never cause\n * exceptions, so this function attempts to handle non-objects gracefully.\n */\n\n\nfunction objCopy(obj) {\n  if (obj == null) {\n    // null or undefined\n    return obj;\n  } else if (Array.isArray(obj)) {\n    return obj.slice();\n  } else if (typeof obj === 'object') {\n    var copy = {};\n    Object.keys(obj).forEach(function (k) {\n      copy[k] = obj[k];\n    });\n    return copy;\n  } else {\n    return obj;\n  }\n}\n\nvar format = util.format;\n\nif (!format) {\n  // If node < 0.6, then use its `util.format`:\n  // <https://github.com/joyent/node/blob/master/lib/util.js#L22>:\n  var inspect = util.inspect;\n  var formatRegExp = /%[sdj%]/g;\n\n  format = function format(f) {\n    if (typeof f !== 'string') {\n      var objects = [];\n\n      for (var i = 0; i < arguments.length; i++) {\n        objects.push(inspect(arguments[i]));\n      }\n\n      return objects.join(' ');\n    }\n\n    var i = 1;\n    var args = arguments;\n    var len = args.length;\n    var str = String(f).replace(formatRegExp, function (x) {\n      if (i >= len) return x;\n\n      switch (x) {\n        case '%s':\n          return String(args[i++]);\n\n        case '%d':\n          return Number(args[i++]);\n\n        case '%j':\n          return fastAndSafeJsonStringify(args[i++]);\n\n        case '%%':\n          return '%';\n\n        default:\n          return x;\n      }\n    });\n\n    for (var x = args[i]; i < len; x = args[++i]) {\n      if (x === null || typeof x !== 'object') {\n        str += ' ' + x;\n      } else {\n        str += ' ' + inspect(x);\n      }\n    }\n\n    return str;\n  };\n}\n/**\n * Gather some caller info 3 stack levels up.\n * See <http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi>.\n */\n\n\nfunction getCaller3Info() {\n  if (this === undefined) {\n    // Cannot access caller info in 'strict' mode.\n    return;\n  }\n\n  var obj = {};\n  var saveLimit = Error.stackTraceLimit;\n  var savePrepare = Error.prepareStackTrace;\n  Error.stackTraceLimit = 3;\n\n  Error.prepareStackTrace = function (_, stack) {\n    var caller = stack[2];\n\n    if (sourceMapSupport) {\n      caller = sourceMapSupport.wrapCallSite(caller);\n    }\n\n    obj.file = caller.getFileName();\n    obj.line = caller.getLineNumber();\n    var func = caller.getFunctionName();\n    if (func) obj.func = func;\n  };\n\n  Error.captureStackTrace(this, getCaller3Info);\n  this.stack;\n  Error.stackTraceLimit = saveLimit;\n  Error.prepareStackTrace = savePrepare;\n  return obj;\n}\n\nfunction _indent(s, indent) {\n  if (!indent) indent = '    ';\n  var lines = s.split(/\\r?\\n/g);\n  return indent + lines.join('\\n' + indent);\n}\n/**\n * Warn about an bunyan processing error.\n *\n * @param msg {String} Message with which to warn.\n * @param dedupKey {String} Optional. A short string key for this warning to\n *      have its warning only printed once.\n */\n\n\nfunction _warn(msg, dedupKey) {\n  assert.ok(msg);\n\n  if (dedupKey) {\n    if (_warned[dedupKey]) {\n      return;\n    }\n\n    _warned[dedupKey] = true;\n  }\n\n  process.stderr.write(msg + '\\n');\n}\n\nfunction _haveWarned(dedupKey) {\n  return _warned[dedupKey];\n}\n\nvar _warned = {};\n\nfunction ConsoleRawStream() {}\n\nConsoleRawStream.prototype.write = function (rec) {\n  if (rec.level < INFO) {\n    console.log(rec);\n  } else if (rec.level < WARN) {\n    console.info(rec);\n  } else if (rec.level < ERROR) {\n    console.warn(rec);\n  } else {\n    console.error(rec);\n  }\n}; //---- Levels\n\n\nvar TRACE = 10;\nvar DEBUG = 20;\nvar INFO = 30;\nvar WARN = 40;\nvar ERROR = 50;\nvar FATAL = 60;\nvar levelFromName = {\n  'trace': TRACE,\n  'debug': DEBUG,\n  'info': INFO,\n  'warn': WARN,\n  'error': ERROR,\n  'fatal': FATAL\n};\nvar nameFromLevel = {};\nObject.keys(levelFromName).forEach(function (name) {\n  nameFromLevel[levelFromName[name]] = name;\n}); // Dtrace probes.\n\nvar dtp = undefined;\nvar probes = dtrace && {};\n/**\n * Resolve a level number, name (upper or lowercase) to a level number value.\n *\n * @param nameOrNum {String|Number} A level name (case-insensitive) or positive\n *      integer level.\n * @api public\n */\n\nfunction resolveLevel(nameOrNum) {\n  var level;\n  var type = typeof nameOrNum;\n\n  if (type === 'string') {\n    level = levelFromName[nameOrNum.toLowerCase()];\n\n    if (!level) {\n      throw new Error(format('unknown level name: \"%s\"', nameOrNum));\n    }\n  } else if (type !== 'number') {\n    throw new TypeError(format('cannot resolve level: invalid arg (%s):', type, nameOrNum));\n  } else if (nameOrNum < 0 || Math.floor(nameOrNum) !== nameOrNum) {\n    throw new TypeError(format('level is not a positive integer: %s', nameOrNum));\n  } else {\n    level = nameOrNum;\n  }\n\n  return level;\n}\n\nfunction isWritable(obj) {\n  if (obj instanceof stream.Writable) {\n    return true;\n  }\n\n  return typeof obj.write === 'function';\n} //---- Logger class\n\n/**\n * Create a Logger instance.\n *\n * @param options {Object} See documentation for full details. At minimum\n *    this must include a 'name' string key. Configuration keys:\n *      - `streams`: specify the logger output streams. This is an array of\n *        objects with these fields:\n *          - `type`: The stream type. See README.md for full details.\n *            Often this is implied by the other fields. Examples are\n *            'file', 'stream' and \"raw\".\n *          - `level`: Defaults to 'info'.\n *          - `path` or `stream`: The specify the file path or writeable\n *            stream to which log records are written. E.g.\n *            `stream: process.stdout`.\n *          - `closeOnExit` (boolean): Optional. Default is true for a\n *            'file' stream when `path` is given, false otherwise.\n *        See README.md for full details.\n *      - `level`: set the level for a single output stream (cannot be used\n *        with `streams`)\n *      - `stream`: the output stream for a logger with just one, e.g.\n *        `process.stdout` (cannot be used with `streams`)\n *      - `serializers`: object mapping log record field names to\n *        serializing functions. See README.md for details.\n *      - `src`: Boolean (default false). Set true to enable 'src' automatic\n *        field with log call source info.\n *    All other keys are log record fields.\n *\n * An alternative *internal* call signature is used for creating a child:\n *    new Logger(<parent logger>, <child options>[, <child opts are simple>]);\n *\n * @param _childSimple (Boolean) An assertion that the given `_childOptions`\n *    (a) only add fields (no config) and (b) no serialization handling is\n *    required for them. IOW, this is a fast path for frequent child\n *    creation.\n */\n\n\nfunction Logger(options, _childOptions, _childSimple) {\n  xxx('Logger start:', options);\n\n  if (!(this instanceof Logger)) {\n    return new Logger(options, _childOptions);\n  } // Input arg validation.\n\n\n  var parent;\n\n  if (_childOptions !== undefined) {\n    parent = options;\n    options = _childOptions;\n\n    if (!(parent instanceof Logger)) {\n      throw new TypeError('invalid Logger creation: do not pass a second arg');\n    }\n  }\n\n  if (!options) {\n    throw new TypeError('options (object) is required');\n  }\n\n  if (!parent) {\n    if (!options.name) {\n      throw new TypeError('options.name (string) is required');\n    }\n  } else {\n    if (options.name) {\n      throw new TypeError('invalid options.name: child cannot set logger name');\n    }\n  }\n\n  if (options.stream && options.streams) {\n    throw new TypeError('cannot mix \"streams\" and \"stream\" options');\n  }\n\n  if (options.streams && !Array.isArray(options.streams)) {\n    throw new TypeError('invalid options.streams: must be an array');\n  }\n\n  if (options.serializers && (typeof options.serializers !== 'object' || Array.isArray(options.serializers))) {\n    throw new TypeError('invalid options.serializers: must be an object');\n  }\n\n  EventEmitter.call(this); // Fast path for simple child creation.\n\n  if (parent && _childSimple) {\n    // `_isSimpleChild` is a signal to stream close handling that this child\n    // owns none of its streams.\n    this._isSimpleChild = true;\n    this._level = parent._level;\n    this.streams = parent.streams;\n    this.serializers = parent.serializers;\n    this.src = parent.src;\n    var fields = this.fields = {};\n    var parentFieldNames = Object.keys(parent.fields);\n\n    for (var i = 0; i < parentFieldNames.length; i++) {\n      var name = parentFieldNames[i];\n      fields[name] = parent.fields[name];\n    }\n\n    var names = Object.keys(options);\n\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      fields[name] = options[name];\n    }\n\n    return;\n  } // Start values.\n\n\n  var self = this;\n\n  if (parent) {\n    this._level = parent._level;\n    this.streams = [];\n\n    for (var i = 0; i < parent.streams.length; i++) {\n      var s = objCopy(parent.streams[i]);\n      s.closeOnExit = false; // Don't own parent stream.\n\n      this.streams.push(s);\n    }\n\n    this.serializers = objCopy(parent.serializers);\n    this.src = parent.src;\n    this.fields = objCopy(parent.fields);\n\n    if (options.level) {\n      this.level(options.level);\n    }\n  } else {\n    this._level = Number.POSITIVE_INFINITY;\n    this.streams = [];\n    this.serializers = null;\n    this.src = false;\n    this.fields = {};\n  }\n\n  if (!dtp && dtrace) {\n    dtp = dtrace.createDTraceProvider('bunyan');\n\n    for (var level in levelFromName) {\n      var probe;\n      probes[levelFromName[level]] = probe = dtp.addProbe('log-' + level, 'char *'); // Explicitly add a reference to dtp to prevent it from being GC'd\n\n      probe.dtp = dtp;\n    }\n\n    dtp.enable();\n  } // Handle *config* options (i.e. options that are not just plain data\n  // for log records).\n\n\n  if (options.stream) {\n    self.addStream({\n      type: 'stream',\n      stream: options.stream,\n      closeOnExit: false,\n      level: options.level\n    });\n  } else if (options.streams) {\n    options.streams.forEach(function (s) {\n      self.addStream(s, options.level);\n    });\n  } else if (parent && options.level) {\n    this.level(options.level);\n  } else if (!parent) {\n    if (runtimeEnv === 'browser') {\n      /*\n       * In the browser we'll be emitting to console.log by default.\n       * Any console.log worth its salt these days can nicely render\n       * and introspect objects (e.g. the Firefox and Chrome console)\n       * so let's emit the raw log record. Are there browsers for which\n       * that breaks things?\n       */\n      self.addStream({\n        type: 'raw',\n        stream: new ConsoleRawStream(),\n        closeOnExit: false,\n        level: options.level\n      });\n    } else {\n      self.addStream({\n        type: 'stream',\n        stream: process.stdout,\n        closeOnExit: false,\n        level: options.level\n      });\n    }\n  }\n\n  if (options.serializers) {\n    self.addSerializers(options.serializers);\n  }\n\n  if (options.src) {\n    this.src = true;\n  }\n\n  xxx('Logger: ', self); // Fields.\n  // These are the default fields for log records (minus the attributes\n  // removed in this constructor). To allow storing raw log records\n  // (unrendered), `this.fields` must never be mutated. Create a copy for\n  // any changes.\n\n  var fields = objCopy(options);\n  delete fields.stream;\n  delete fields.level;\n  delete fields.streams;\n  delete fields.serializers;\n  delete fields.src;\n\n  if (this.serializers) {\n    this._applySerializers(fields);\n  }\n\n  if (!fields.hostname && !self.fields.hostname) {\n    fields.hostname = os.hostname();\n  }\n\n  if (!fields.pid) {\n    fields.pid = process.pid;\n  }\n\n  Object.keys(fields).forEach(function (k) {\n    self.fields[k] = fields[k];\n  });\n}\n\nutil.inherits(Logger, EventEmitter);\n/**\n * Add a stream\n *\n * @param stream {Object}. Object with these fields:\n *    - `type`: The stream type. See README.md for full details.\n *      Often this is implied by the other fields. Examples are\n *      'file', 'stream' and \"raw\".\n *    - `path` or `stream`: The specify the file path or writeable\n *      stream to which log records are written. E.g.\n *      `stream: process.stdout`.\n *    - `level`: Optional. Falls back to `defaultLevel`.\n *    - `closeOnExit` (boolean): Optional. Default is true for a\n *      'file' stream when `path` is given, false otherwise.\n *    See README.md for full details.\n * @param defaultLevel {Number|String} Optional. A level to use if\n *      `stream.level` is not set. If neither is given, this defaults to INFO.\n */\n\nLogger.prototype.addStream = function addStream(s, defaultLevel) {\n  var self = this;\n\n  if (defaultLevel === null || defaultLevel === undefined) {\n    defaultLevel = INFO;\n  }\n\n  s = objCopy(s); // Implicit 'type' from other args.\n\n  if (!s.type) {\n    if (s.stream) {\n      s.type = 'stream';\n    } else if (s.path) {\n      s.type = 'file';\n    }\n  }\n\n  s.raw = s.type === 'raw'; // PERF: Allow for faster check in `_emit`.\n\n  if (s.level !== undefined) {\n    s.level = resolveLevel(s.level);\n  } else {\n    s.level = resolveLevel(defaultLevel);\n  }\n\n  if (s.level < self._level) {\n    self._level = s.level;\n  }\n\n  switch (s.type) {\n    case 'stream':\n      assert.ok(isWritable(s.stream), '\"stream\" stream is not writable: ' + util.inspect(s.stream));\n\n      if (!s.closeOnExit) {\n        s.closeOnExit = false;\n      }\n\n      break;\n\n    case 'file':\n      if (s.reemitErrorEvents === undefined) {\n        s.reemitErrorEvents = true;\n      }\n\n      if (!s.stream) {\n        s.stream = fs.createWriteStream(s.path, {\n          flags: 'a',\n          encoding: 'utf8'\n        });\n\n        if (!s.closeOnExit) {\n          s.closeOnExit = true;\n        }\n      } else {\n        if (!s.closeOnExit) {\n          s.closeOnExit = false;\n        }\n      }\n\n      break;\n\n    case 'rotating-file':\n      assert.ok(!s.stream, '\"rotating-file\" stream should not give a \"stream\"');\n      assert.ok(s.path);\n      assert.ok(mv, '\"rotating-file\" stream type is not supported: ' + 'missing \"mv\" module');\n      s.stream = new RotatingFileStream(s);\n\n      if (!s.closeOnExit) {\n        s.closeOnExit = true;\n      }\n\n      break;\n\n    case 'raw':\n      if (!s.closeOnExit) {\n        s.closeOnExit = false;\n      }\n\n      break;\n\n    default:\n      throw new TypeError('unknown stream type \"' + s.type + '\"');\n  }\n\n  if (s.reemitErrorEvents && typeof s.stream.on === 'function') {\n    // TODO: When we have `<logger>.close()`, it should remove event\n    //      listeners to not leak Logger instances.\n    s.stream.on('error', function onStreamError(err) {\n      self.emit('error', err, s);\n    });\n  }\n\n  self.streams.push(s);\n  delete self.haveNonRawStreams; // reset\n};\n/**\n * Add serializers\n *\n * @param serializers {Object} Optional. Object mapping log record field names\n *    to serializing functions. See README.md for details.\n */\n\n\nLogger.prototype.addSerializers = function addSerializers(serializers) {\n  var self = this;\n\n  if (!self.serializers) {\n    self.serializers = {};\n  }\n\n  Object.keys(serializers).forEach(function (field) {\n    var serializer = serializers[field];\n\n    if (typeof serializer !== 'function') {\n      throw new TypeError(format('invalid serializer for \"%s\" field: must be a function', field));\n    } else {\n      self.serializers[field] = serializer;\n    }\n  });\n};\n/**\n * Create a child logger, typically to add a few log record fields.\n *\n * This can be useful when passing a logger to a sub-component, e.g. a\n * 'wuzzle' component of your service:\n *\n *    var wuzzleLog = log.child({component: 'wuzzle'})\n *    var wuzzle = new Wuzzle({..., log: wuzzleLog})\n *\n * Then log records from the wuzzle code will have the same structure as\n * the app log, *plus the component='wuzzle' field*.\n *\n * @param options {Object} Optional. Set of options to apply to the child.\n *    All of the same options for a new Logger apply here. Notes:\n *      - The parent's streams are inherited and cannot be removed in this\n *        call. Any given `streams` are *added* to the set inherited from\n *        the parent.\n *      - The parent's serializers are inherited, though can effectively be\n *        overwritten by using duplicate keys.\n *      - Can use `level` to set the level of the streams inherited from\n *        the parent. The level for the parent is NOT affected.\n * @param simple {Boolean} Optional. Set to true to assert that `options`\n *    (a) only add fields (no config) and (b) no serialization handling is\n *    required for them. IOW, this is a fast path for frequent child\n *    creation. See 'tools/timechild.js' for numbers.\n */\n\n\nLogger.prototype.child = function (options, simple) {\n  return new this.constructor(this, options || {}, simple);\n};\n/**\n * A convenience method to reopen 'file' streams on a logger. This can be\n * useful with external log rotation utilities that move and re-open log files\n * (e.g. logrotate on Linux, logadm on SmartOS/Illumos). Those utilities\n * typically have rotation options to copy-and-truncate the log file, but\n * you may not want to use that. An alternative is to do this in your\n * application:\n *\n *      var log = bunyan.createLogger(...);\n *      ...\n *      process.on('SIGUSR2', function () {\n *          log.reopenFileStreams();\n *      });\n *      ...\n *\n * See <https://github.com/trentm/node-bunyan/issues/104>.\n */\n\n\nLogger.prototype.reopenFileStreams = function () {\n  var self = this;\n  self.streams.forEach(function (s) {\n    if (s.type === 'file') {\n      if (s.stream) {\n        // Not sure if typically would want this, or more immediate\n        // `s.stream.destroy()`.\n        s.stream.end();\n        s.stream.destroySoon();\n        delete s.stream;\n      }\n\n      s.stream = fs.createWriteStream(s.path, {\n        flags: 'a',\n        encoding: 'utf8'\n      });\n      s.stream.on('error', function (err) {\n        self.emit('error', err, s);\n      });\n    }\n  });\n};\n/* BEGIN JSSTYLED */\n\n/**\n * Close this logger.\n *\n * This closes streams (that it owns, as per 'endOnClose' attributes on\n * streams), etc. Typically you **don't** need to bother calling this.\nLogger.prototype.close = function () {\n    if (this._closed) {\n        return;\n    }\n    if (!this._isSimpleChild) {\n        self.streams.forEach(function (s) {\n            if (s.endOnClose) {\n                xxx('closing stream s:', s);\n                s.stream.end();\n                s.endOnClose = false;\n            }\n        });\n    }\n    this._closed = true;\n}\n */\n\n/* END JSSTYLED */\n\n/**\n * Get/set the level of all streams on this logger.\n *\n * Get Usage:\n *    // Returns the current log level (lowest level of all its streams).\n *    log.level() -> INFO\n *\n * Set Usage:\n *    log.level(INFO)       // set all streams to level INFO\n *    log.level('info')     // can use 'info' et al aliases\n */\n\n\nLogger.prototype.level = function level(value) {\n  if (value === undefined) {\n    return this._level;\n  }\n\n  var newLevel = resolveLevel(value);\n  var len = this.streams.length;\n\n  for (var i = 0; i < len; i++) {\n    this.streams[i].level = newLevel;\n  }\n\n  this._level = newLevel;\n};\n/**\n * Get/set the level of a particular stream on this logger.\n *\n * Get Usage:\n *    // Returns an array of the levels of each stream.\n *    log.levels() -> [TRACE, INFO]\n *\n *    // Returns a level of the identified stream.\n *    log.levels(0) -> TRACE      // level of stream at index 0\n *    log.levels('foo')           // level of stream with name 'foo'\n *\n * Set Usage:\n *    log.levels(0, INFO)         // set level of stream 0 to INFO\n *    log.levels(0, 'info')       // can use 'info' et al aliases\n *    log.levels('foo', WARN)     // set stream named 'foo' to WARN\n *\n * Stream names: When streams are defined, they can optionally be given\n * a name. For example,\n *       log = new Logger({\n *         streams: [\n *           {\n *             name: 'foo',\n *             path: '/var/log/my-service/foo.log'\n *             level: 'trace'\n *           },\n *         ...\n *\n * @param name {String|Number} The stream index or name.\n * @param value {Number|String} The level value (INFO) or alias ('info').\n *    If not given, this is a 'get' operation.\n * @throws {Error} If there is no stream with the given name.\n */\n\n\nLogger.prototype.levels = function levels(name, value) {\n  if (name === undefined) {\n    assert.equal(value, undefined);\n    return this.streams.map(function (s) {\n      return s.level;\n    });\n  }\n\n  var stream;\n\n  if (typeof name === 'number') {\n    stream = this.streams[name];\n\n    if (stream === undefined) {\n      throw new Error('invalid stream index: ' + name);\n    }\n  } else {\n    var len = this.streams.length;\n\n    for (var i = 0; i < len; i++) {\n      var s = this.streams[i];\n\n      if (s.name === name) {\n        stream = s;\n        break;\n      }\n    }\n\n    if (!stream) {\n      throw new Error(format('no stream with name \"%s\"', name));\n    }\n  }\n\n  if (value === undefined) {\n    return stream.level;\n  } else {\n    var newLevel = resolveLevel(value);\n    stream.level = newLevel;\n\n    if (newLevel < this._level) {\n      this._level = newLevel;\n    }\n  }\n};\n/**\n * Apply registered serializers to the appropriate keys in the given fields.\n *\n * Pre-condition: This is only called if there is at least one serializer.\n *\n * @param fields (Object) The log record fields.\n * @param excludeFields (Object) Optional mapping of keys to `true` for\n *    keys to NOT apply a serializer.\n */\n\n\nLogger.prototype._applySerializers = function (fields, excludeFields) {\n  var self = this;\n  xxx('_applySerializers: excludeFields', excludeFields); // Check each serializer against these (presuming number of serializers\n  // is typically less than number of fields).\n\n  Object.keys(this.serializers).forEach(function (name) {\n    if (fields[name] === undefined || excludeFields && excludeFields[name]) {\n      return;\n    }\n\n    xxx('_applySerializers; apply to \"%s\" key', name);\n\n    try {\n      fields[name] = self.serializers[name](fields[name]);\n    } catch (err) {\n      _warn(format('bunyan: ERROR: Exception thrown from the \"%s\" ' + 'Bunyan serializer. This should never happen. This is a bug ' + 'in that serializer function.\\n%s', name, err.stack || err));\n\n      fields[name] = format('(Error in Bunyan log \"%s\" serializer ' + 'broke field. See stderr for details.)', name);\n    }\n  });\n};\n/**\n * Emit a log record.\n *\n * @param rec {log record}\n * @param noemit {Boolean} Optional. Set to true to skip emission\n *      and just return the JSON string.\n */\n\n\nLogger.prototype._emit = function (rec, noemit) {\n  var i; // Lazily determine if this Logger has non-'raw' streams. If there are\n  // any, then we need to stringify the log record.\n\n  if (this.haveNonRawStreams === undefined) {\n    this.haveNonRawStreams = false;\n\n    for (i = 0; i < this.streams.length; i++) {\n      if (!this.streams[i].raw) {\n        this.haveNonRawStreams = true;\n        break;\n      }\n    }\n  } // Stringify the object (creates a warning str on error).\n\n\n  var str;\n\n  if (noemit || this.haveNonRawStreams) {\n    str = fastAndSafeJsonStringify(rec) + '\\n';\n  }\n\n  if (noemit) return str;\n  var level = rec.level;\n\n  for (i = 0; i < this.streams.length; i++) {\n    var s = this.streams[i];\n\n    if (s.level <= level) {\n      xxx('writing log rec \"%s\" to \"%s\" stream (%d <= %d): %j', rec.msg, s.type, s.level, level, rec);\n      s.stream.write(s.raw ? rec : str);\n    }\n  }\n\n  ;\n  return str;\n};\n/**\n * Build a record object suitable for emitting from the arguments\n * provided to the a log emitter.\n */\n\n\nfunction mkRecord(log, minLevel, args) {\n  var excludeFields, fields, msgArgs;\n\n  if (args[0] instanceof Error) {\n    // `log.<level>(err, ...)`\n    fields = {\n      // Use this Logger's err serializer, if defined.\n      err: log.serializers && log.serializers.err ? log.serializers.err(args[0]) : Logger.stdSerializers.err(args[0])\n    };\n    excludeFields = {\n      err: true\n    };\n\n    if (args.length === 1) {\n      msgArgs = [fields.err.message];\n    } else {\n      msgArgs = args.slice(1);\n    }\n  } else if (typeof args[0] !== 'object' || Array.isArray(args[0])) {\n    // `log.<level>(msg, ...)`\n    fields = null;\n    msgArgs = args.slice();\n  } else if (Buffer.isBuffer(args[0])) {\n    // `log.<level>(buf, ...)`\n    // Almost certainly an error, show `inspect(buf)`. See bunyan\n    // issue #35.\n    fields = null;\n    msgArgs = args.slice();\n    msgArgs[0] = util.inspect(msgArgs[0]);\n  } else {\n    // `log.<level>(fields, msg, ...)`\n    fields = args[0];\n\n    if (fields && args.length === 1 && fields.err && fields.err instanceof Error) {\n      msgArgs = [fields.err.message];\n    } else {\n      msgArgs = args.slice(1);\n    }\n  } // Build up the record object.\n\n\n  var rec = objCopy(log.fields);\n  var level = rec.level = minLevel;\n  var recFields = fields ? objCopy(fields) : null;\n\n  if (recFields) {\n    if (log.serializers) {\n      log._applySerializers(recFields, excludeFields);\n    }\n\n    Object.keys(recFields).forEach(function (k) {\n      rec[k] = recFields[k];\n    });\n  }\n\n  rec.msg = format.apply(log, msgArgs);\n\n  if (!rec.time) {\n    rec.time = new Date();\n  } // Get call source info\n\n\n  if (log.src && !rec.src) {\n    rec.src = getCaller3Info();\n  }\n\n  rec.v = LOG_VERSION;\n  return rec;\n}\n\n;\n/**\n * Build an array that dtrace-provider can use to fire a USDT probe. If we've\n * already built the appropriate string, we use it. Otherwise, build the\n * record object and stringify it.\n */\n\nfunction mkProbeArgs(str, log, minLevel, msgArgs) {\n  return [str || log._emit(mkRecord(log, minLevel, msgArgs), true)];\n}\n/**\n * Build a log emitter function for level minLevel. I.e. this is the\n * creator of `log.info`, `log.error`, etc.\n */\n\n\nfunction mkLogEmitter(minLevel) {\n  return function () {\n    var log = this;\n    var str = null;\n    var rec = null;\n\n    if (!this._emit) {\n      /*\n       * Show this invalid Bunyan usage warning *once*.\n       *\n       * See <https://github.com/trentm/node-bunyan/issues/100> for\n       * an example of how this can happen.\n       */\n      var dedupKey = 'unbound';\n\n      if (!_haveWarned[dedupKey]) {\n        var caller = getCaller3Info();\n\n        _warn(format('bunyan usage error: %s:%s: attempt to log ' + 'with an unbound log method: `this` is: %s', caller.file, caller.line, util.inspect(this)), dedupKey);\n      }\n\n      return;\n    } else if (arguments.length === 0) {\n      // `log.<level>()`\n      return this._level <= minLevel;\n    }\n\n    var msgArgs = new Array(arguments.length);\n\n    for (var i = 0; i < msgArgs.length; ++i) {\n      msgArgs[i] = arguments[i];\n    }\n\n    if (this._level <= minLevel) {\n      rec = mkRecord(log, minLevel, msgArgs);\n      str = this._emit(rec);\n    }\n\n    if (probes) {\n      probes[minLevel].fire(mkProbeArgs, str, log, minLevel, msgArgs);\n    }\n  };\n}\n/**\n * The functions below log a record at a specific level.\n *\n * Usages:\n *    log.<level>()  -> boolean is-trace-enabled\n *    log.<level>(<Error> err, [<string> msg, ...])\n *    log.<level>(<string> msg, ...)\n *    log.<level>(<object> fields, <string> msg, ...)\n *\n * where <level> is the lowercase version of the log level. E.g.:\n *\n *    log.info()\n *\n * @params fields {Object} Optional set of additional fields to log.\n * @params msg {String} Log message. This can be followed by additional\n *    arguments that are handled like\n *    [util.format](http://nodejs.org/docs/latest/api/all.html#util.format).\n */\n\n\nLogger.prototype.trace = mkLogEmitter(TRACE);\nLogger.prototype.debug = mkLogEmitter(DEBUG);\nLogger.prototype.info = mkLogEmitter(INFO);\nLogger.prototype.warn = mkLogEmitter(WARN);\nLogger.prototype.error = mkLogEmitter(ERROR);\nLogger.prototype.fatal = mkLogEmitter(FATAL); //---- Standard serializers\n// A serializer is a function that serializes a JavaScript object to a\n// JSON representation for logging. There is a standard set of presumed\n// interesting objects in node.js-land.\n\nLogger.stdSerializers = {}; // Serialize an HTTP request.\n\nLogger.stdSerializers.req = function (req) {\n  if (!req || !req.connection) return req;\n  return {\n    method: req.method,\n    url: req.url,\n    headers: req.headers,\n    remoteAddress: req.connection.remoteAddress,\n    remotePort: req.connection.remotePort\n  }; // Trailers: Skipping for speed. If you need trailers in your app, then\n  // make a custom serializer.\n  //if (Object.keys(trailers).length > 0) {\n  //  obj.trailers = req.trailers;\n  //}\n}; // Serialize an HTTP response.\n\n\nLogger.stdSerializers.res = function (res) {\n  if (!res || !res.statusCode) return res;\n  return {\n    statusCode: res.statusCode,\n    header: res._header\n  };\n};\n/*\n * This function dumps long stack traces for exceptions having a cause()\n * method. The error classes from\n * [verror](https://github.com/davepacheco/node-verror) and\n * [restify v2.0](https://github.com/mcavage/node-restify) are examples.\n *\n * Based on `dumpException` in\n * https://github.com/davepacheco/node-extsprintf/blob/master/lib/extsprintf.js\n */\n\n\nfunction getFullErrorStack(ex) {\n  var ret = ex.stack || ex.toString();\n\n  if (ex.cause && typeof ex.cause === 'function') {\n    var cex = ex.cause();\n\n    if (cex) {\n      ret += '\\nCaused by: ' + getFullErrorStack(cex);\n    }\n  }\n\n  return ret;\n} // Serialize an Error object\n// (Core error properties are enumerable in node 0.4, not in 0.6).\n\n\nvar errSerializer = Logger.stdSerializers.err = function (err) {\n  if (!err || !err.stack) return err;\n  var obj = {\n    message: err.message,\n    name: err.name,\n    stack: getFullErrorStack(err),\n    code: err.code,\n    signal: err.signal\n  };\n  return obj;\n}; // A JSON stringifier that handles cycles safely - tracks seen values in a Set.\n\n\nfunction safeCyclesSet() {\n  var seen = new Set();\n  return function (key, val) {\n    if (!val || typeof val !== 'object') {\n      return val;\n    }\n\n    if (seen.has(val)) {\n      return '[Circular]';\n    }\n\n    seen.add(val);\n    return val;\n  };\n}\n/**\n * A JSON stringifier that handles cycles safely - tracks seen vals in an Array.\n *\n * Note: This approach has performance problems when dealing with large objects,\n * see trentm/node-bunyan#445, but since this is the only option for node 0.10\n * and earlier (as Set was introduced in Node 0.12), it's used as a fallback\n * when Set is not available.\n */\n\n\nfunction safeCyclesArray() {\n  var seen = [];\n  return function (key, val) {\n    if (!val || typeof val !== 'object') {\n      return val;\n    }\n\n    if (seen.indexOf(val) !== -1) {\n      return '[Circular]';\n    }\n\n    seen.push(val);\n    return val;\n  };\n}\n/**\n * A JSON stringifier that handles cycles safely.\n *\n * Usage: JSON.stringify(obj, safeCycles())\n *\n * Choose the best safe cycle function from what is available - see\n * trentm/node-bunyan#445.\n */\n\n\nvar safeCycles = typeof Set !== 'undefined' ? safeCyclesSet : safeCyclesArray;\n/**\n * A fast JSON.stringify that handles cycles and getter exceptions (when\n * safeJsonStringify is installed).\n *\n * This function attempts to use the regular JSON.stringify for speed, but on\n * error (e.g. JSON cycle detection exception) it falls back to safe stringify\n * handlers that can deal with cycles and/or getter exceptions.\n */\n\nfunction fastAndSafeJsonStringify(rec) {\n  try {\n    return JSON.stringify(rec);\n  } catch (ex) {\n    try {\n      return JSON.stringify(rec, safeCycles());\n    } catch (e) {\n      if (safeJsonStringify) {\n        return safeJsonStringify(rec);\n      } else {\n        var dedupKey = e.stack.split(/\\n/g, 3).join('\\n');\n\n        _warn('bunyan: ERROR: Exception in ' + '`JSON.stringify(rec)`. You can install the ' + '\"safe-json-stringify\" module to have Bunyan fallback ' + 'to safer stringification. Record:\\n' + _indent(format('%s\\n%s', util.inspect(rec), e.stack)), dedupKey);\n\n        return format('(Exception in JSON.stringify(rec): %j. ' + 'See stderr for details.)', e.message);\n      }\n    }\n  }\n}\n\nvar RotatingFileStream = null;\n\nif (mv) {\n  RotatingFileStream = function RotatingFileStream(options) {\n    this.path = options.path;\n    this.count = options.count == null ? 10 : options.count;\n    assert.equal(typeof this.count, 'number', format('rotating-file stream \"count\" is not a number: %j (%s) in %j', this.count, typeof this.count, this));\n    assert.ok(this.count >= 0, format('rotating-file stream \"count\" is not >= 0: %j in %j', this.count, this)); // Parse `options.period`.\n\n    if (options.period) {\n      // <number><scope> where scope is:\n      //    h   hours (at the start of the hour)\n      //    d   days (at the start of the day, i.e. just after midnight)\n      //    w   weeks (at the start of Sunday)\n      //    m   months (on the first of the month)\n      //    y   years (at the start of Jan 1st)\n      // with special values 'hourly' (1h), 'daily' (1d), \"weekly\" (1w),\n      // 'monthly' (1m) and 'yearly' (1y)\n      var period = {\n        'hourly': '1h',\n        'daily': '1d',\n        'weekly': '1w',\n        'monthly': '1m',\n        'yearly': '1y'\n      }[options.period] || options.period;\n      var m = /^([1-9][0-9]*)([hdwmy]|ms)$/.exec(period);\n\n      if (!m) {\n        throw new Error(format('invalid period: \"%s\"', options.period));\n      }\n\n      this.periodNum = Number(m[1]);\n      this.periodScope = m[2];\n    } else {\n      this.periodNum = 1;\n      this.periodScope = 'd';\n    }\n\n    var lastModified = null;\n\n    try {\n      var fileInfo = fs.statSync(this.path);\n      lastModified = fileInfo.mtime.getTime();\n    } catch (err) {// file doesn't exist\n    }\n\n    var rotateAfterOpen = false;\n\n    if (lastModified) {\n      var lastRotTime = this._calcRotTime(0);\n\n      if (lastModified < lastRotTime) {\n        rotateAfterOpen = true;\n      }\n    } // TODO: template support for backup files\n    // template: <path to which to rotate>\n    //      default is %P.%n\n    //      '/var/log/archive/foo.log'  -> foo.log.%n\n    //      '/var/log/archive/foo.log.%n'\n    //      codes:\n    //          XXX support strftime codes (per node version of those)\n    //              or whatever module. Pick non-colliding for extra\n    //              codes\n    //          %P      `path` base value\n    //          %n      integer number of rotated log (1,2,3,...)\n    //          %d      datetime in YYYY-MM-DD_HH-MM-SS\n    //                      XXX what should default date format be?\n    //                          prior art? Want to avoid ':' in\n    //                          filenames (illegal on Windows for one).\n\n\n    this.stream = fs.createWriteStream(this.path, {\n      flags: 'a',\n      encoding: 'utf8'\n    });\n    this.rotQueue = [];\n    this.rotating = false;\n\n    if (rotateAfterOpen) {\n      this._debug('rotateAfterOpen -> call rotate()');\n\n      this.rotate();\n    } else {\n      this._setupNextRot();\n    }\n  };\n\n  util.inherits(RotatingFileStream, EventEmitter);\n\n  RotatingFileStream.prototype._debug = function () {\n    // Set this to `true` to add debug logging.\n    if (false) {\n      if (arguments.length === 0) {\n        return true;\n      }\n\n      var args = Array.prototype.slice.call(arguments);\n      args[0] = '[' + new Date().toISOString() + ', ' + this.path + '] ' + args[0];\n      console.log.apply(this, args);\n    } else {\n      return false;\n    }\n  };\n\n  RotatingFileStream.prototype._setupNextRot = function () {\n    this.rotAt = this._calcRotTime(1);\n\n    this._setRotationTimer();\n  };\n\n  RotatingFileStream.prototype._setRotationTimer = function () {\n    var self = this;\n    var delay = this.rotAt - Date.now(); // Cap timeout to Node's max setTimeout, see\n    // <https://github.com/joyent/node/issues/8656>.\n\n    var TIMEOUT_MAX = 2147483647; // 2^31-1\n\n    if (delay > TIMEOUT_MAX) {\n      delay = TIMEOUT_MAX;\n    }\n\n    this.timeout = setTimeout(function () {\n      self._debug('_setRotationTimer timeout -> call rotate()');\n\n      self.rotate();\n    }, delay);\n\n    if (typeof this.timeout.unref === 'function') {\n      this.timeout.unref();\n    }\n  };\n\n  RotatingFileStream.prototype._calcRotTime = function _calcRotTime(periodOffset) {\n    this._debug('_calcRotTime: %s%s', this.periodNum, this.periodScope);\n\n    var d = new Date();\n\n    this._debug('  now local: %s', d);\n\n    this._debug('    now utc: %s', d.toISOString());\n\n    var rotAt;\n\n    switch (this.periodScope) {\n      case 'ms':\n        // Hidden millisecond period for debugging.\n        if (this.rotAt) {\n          rotAt = this.rotAt + this.periodNum * periodOffset;\n        } else {\n          rotAt = Date.now() + this.periodNum * periodOffset;\n        }\n\n        break;\n\n      case 'h':\n        if (this.rotAt) {\n          rotAt = this.rotAt + this.periodNum * 60 * 60 * 1000 * periodOffset;\n        } else {\n          // First time: top of the next hour.\n          rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours() + periodOffset);\n        }\n\n        break;\n\n      case 'd':\n        if (this.rotAt) {\n          rotAt = this.rotAt + this.periodNum * 24 * 60 * 60 * 1000 * periodOffset;\n        } else {\n          // First time: start of tomorrow (i.e. at the coming midnight) UTC.\n          rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate() + periodOffset);\n        }\n\n        break;\n\n      case 'w':\n        // Currently, always on Sunday morning at 00:00:00 (UTC).\n        if (this.rotAt) {\n          rotAt = this.rotAt + this.periodNum * 7 * 24 * 60 * 60 * 1000 * periodOffset;\n        } else {\n          // First time: this coming Sunday.\n          var dayOffset = 7 - d.getUTCDay();\n\n          if (periodOffset < 1) {\n            dayOffset = -d.getUTCDay();\n          }\n\n          if (periodOffset > 1 || periodOffset < -1) {\n            dayOffset += 7 * periodOffset;\n          }\n\n          rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate() + dayOffset);\n        }\n\n        break;\n\n      case 'm':\n        if (this.rotAt) {\n          rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth() + this.periodNum * periodOffset, 1);\n        } else {\n          // First time: the start of the next month.\n          rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth() + periodOffset, 1);\n        }\n\n        break;\n\n      case 'y':\n        if (this.rotAt) {\n          rotAt = Date.UTC(d.getUTCFullYear() + this.periodNum * periodOffset, 0, 1);\n        } else {\n          // First time: the start of the next year.\n          rotAt = Date.UTC(d.getUTCFullYear() + periodOffset, 0, 1);\n        }\n\n        break;\n\n      default:\n        assert.fail(format('invalid period scope: \"%s\"', this.periodScope));\n    }\n\n    if (this._debug()) {\n      this._debug('  **rotAt**: %s (utc: %s)', rotAt, new Date(rotAt).toUTCString());\n\n      var now = Date.now();\n\n      this._debug('        now: %s (%sms == %smin == %sh to go)', now, rotAt - now, (rotAt - now) / 1000 / 60, (rotAt - now) / 1000 / 60 / 60);\n    }\n\n    return rotAt;\n  };\n\n  RotatingFileStream.prototype.rotate = function rotate() {\n    // XXX What about shutdown?\n    var self = this; // If rotation period is > ~25 days, we have to break into multiple\n    // setTimeout's. See <https://github.com/joyent/node/issues/8656>.\n\n    if (self.rotAt && self.rotAt > Date.now()) {\n      return self._setRotationTimer();\n    }\n\n    this._debug('rotate');\n\n    if (self.rotating) {\n      throw new TypeError('cannot start a rotation when already rotating');\n    }\n\n    self.rotating = true;\n    self.stream.end(); // XXX can do moves sync after this? test at high rate\n\n    function del() {\n      var toDel = self.path + '.' + String(n - 1);\n\n      if (n === 0) {\n        toDel = self.path;\n      }\n\n      n -= 1;\n\n      self._debug('  rm %s', toDel);\n\n      fs.unlink(toDel, function (delErr) {\n        //XXX handle err other than not exists\n        moves();\n      });\n    }\n\n    function moves() {\n      if (self.count === 0 || n < 0) {\n        return finish();\n      }\n\n      var before = self.path;\n      var after = self.path + '.' + String(n);\n\n      if (n > 0) {\n        before += '.' + String(n - 1);\n      }\n\n      n -= 1;\n      fs.exists(before, function (exists) {\n        if (!exists) {\n          moves();\n        } else {\n          self._debug('  mv %s %s', before, after);\n\n          mv(before, after, function (mvErr) {\n            if (mvErr) {\n              self.emit('error', mvErr);\n              finish(); // XXX finish here?\n            } else {\n              moves();\n            }\n          });\n        }\n      });\n    }\n\n    function finish() {\n      self._debug('  open %s', self.path);\n\n      self.stream = fs.createWriteStream(self.path, {\n        flags: 'a',\n        encoding: 'utf8'\n      });\n      var q = self.rotQueue,\n          len = q.length;\n\n      for (var i = 0; i < len; i++) {\n        self.stream.write(q[i]);\n      }\n\n      self.rotQueue = [];\n      self.rotating = false;\n      self.emit('drain');\n\n      self._setupNextRot();\n    }\n\n    var n = this.count;\n    del();\n  };\n\n  RotatingFileStream.prototype.write = function write(s) {\n    if (this.rotating) {\n      this.rotQueue.push(s);\n      return false;\n    } else {\n      return this.stream.write(s);\n    }\n  };\n\n  RotatingFileStream.prototype.end = function end(s) {\n    this.stream.end();\n  };\n\n  RotatingFileStream.prototype.destroy = function destroy(s) {\n    this.stream.destroy();\n  };\n\n  RotatingFileStream.prototype.destroySoon = function destroySoon(s) {\n    this.stream.destroySoon();\n  };\n}\n/* if (mv) */\n\n/**\n * RingBuffer is a Writable Stream that just stores the last N records in\n * memory.\n *\n * @param options {Object}, with the following fields:\n *\n *    - limit: number of records to keep in memory\n */\n\n\nfunction RingBuffer(options) {\n  this.limit = options && options.limit ? options.limit : 100;\n  this.writable = true;\n  this.records = [];\n  EventEmitter.call(this);\n}\n\nutil.inherits(RingBuffer, EventEmitter);\n\nRingBuffer.prototype.write = function (record) {\n  if (!this.writable) throw new Error('RingBuffer has been ended already');\n  this.records.push(record);\n  if (this.records.length > this.limit) this.records.shift();\n  return true;\n};\n\nRingBuffer.prototype.end = function () {\n  if (arguments.length > 0) this.write.apply(this, Array.prototype.slice.call(arguments));\n  this.writable = false;\n};\n\nRingBuffer.prototype.destroy = function () {\n  this.writable = false;\n  this.emit('close');\n};\n\nRingBuffer.prototype.destroySoon = function () {\n  this.destroy();\n}; //---- Exports\n\n\nmodule.exports = Logger;\nmodule.exports.TRACE = TRACE;\nmodule.exports.DEBUG = DEBUG;\nmodule.exports.INFO = INFO;\nmodule.exports.WARN = WARN;\nmodule.exports.ERROR = ERROR;\nmodule.exports.FATAL = FATAL;\nmodule.exports.resolveLevel = resolveLevel;\nmodule.exports.levelFromName = levelFromName;\nmodule.exports.nameFromLevel = nameFromLevel;\nmodule.exports.VERSION = VERSION;\nmodule.exports.LOG_VERSION = LOG_VERSION;\n\nmodule.exports.createLogger = function createLogger(options) {\n  return new Logger(options);\n};\n\nmodule.exports.RingBuffer = RingBuffer;\nmodule.exports.RotatingFileStream = RotatingFileStream; // Useful for custom `type == 'raw'` streams that may do JSON stringification\n// of log records themselves. Usage:\n//    var str = JSON.stringify(rec, bunyan.safeCycles());\n\nmodule.exports.safeCycles = safeCycles;","map":null,"metadata":{},"sourceType":"script"}