{"ast":null,"code":"'use strict';\n\nvar assert = require('assert-plus');\n\nvar pidusage = require('pidusage');\n\nvar errors = require('restify-errors');\n\nvar EWMA = require('ewma');\n/**\n * cpuUsageThrottle is a middleware that rejects a variable number of requests\n * (between 0% and 100%) based on a historical view of CPU utilization of a\n * Node.js process. Essentially, this plugin allows you to define what\n * constitutes a saturated Node.js process via CPU utilization and it will\n * handle dropping a % of requests based on that definiton. This is useful when\n * you would like to keep CPU bound tasks from piling up causing an increased\n * per-request latency.\n *\n * The algorithm asks you for a maximum CPU utilization rate, which it uses to\n * determine at what point it should be rejecting 100% of traffic. For a normal\n * Node.js service, this is 1 since Node is single threaded. It uses this,\n * paired with a limit that you provide to determine the total % of traffic it\n * should be rejecting. For example, if you specify a limit of .5 and a max of\n * 1, and the current EWMA (next paragraph) value reads .75, this plugin will\n * reject approximately 50% of all requests.\n *\n * When looking at the process' CPU usage, this algorithm will take a load\n * average over a user specified interval. example, if given an interval of\n * 250ms, this plugin will attempt to record the average CPU utilization over\n * 250ms intervals. Due to contention for resources, the duration of each\n * average may be wider or narrower than 250ms. To compensate for this, we use\n * an exponentially weighted moving average. The EWMA algorithm is provided by\n * the ewma module. The parameter for configuring the EWMA is halfLife. This\n * value controls how quickly each load average measurment decays to half it's\n * value when being represented in the current average. For example, if you\n * have an interval of 250, and a halfLife of 250, you will take the previous\n * ewma value multiplied by 0.5 and add it to the new CPU utilization average\n * measurement multiplied by 0.5. The previous value and the new measurement\n * would each represent 50% of the new value. A good way of thinking about the\n * halfLife is in terms of how responsive this plugin will be to spikes in CPU\n * utilization. The higher the halfLife, the longer CPU utilization will have\n * to remain above your defined limit before this plugin begins rejecting\n * requests and, converserly, the longer it will have to drop below your limit\n * before the plugin begins accepting requests again. This is a knob you will\n * want to with play when trying to determine the ideal value for your use\n * case.\n *\n * For a better understanding of the EWMA algorithn, refer to the documentation\n * for the ewma module.\n *\n * @public\n * @function cpuUsageThrottle\n * @param {Object} opts - Configure this plugin.\n * @param {Number} [opts.limit] - The point at which restify will begin\n *    rejecting a % of all requests at the front door.\n *    This value is a percentage.\n *    For example 0.8 === 80% average CPU utilization. Defaults to 0.75.\n * @param {Number} [opts.max] - The point at which restify will reject 100% of\n *    all requests at the front door. This is used in conjunction with limit to\n *    determine what % of traffic restify needs to reject when attempting to\n *    bring the average load back to the user requested values. Since Node.js is\n *    single threaded, the default for this is 1. In some rare cases, a Node.js\n *    process can exceed 100% CPU usage and you will want to update this value.\n * @param {Number} [opts.interval] - How frequently we calculate the average CPU\n *    utilization. When we calculate an average CPU utilization, we calculate it\n *    over this interval, and this drives whether or not we should be shedding\n *    load. This can be thought of as a \"resolution\" where the lower this value,\n *    the higher the resolution our load average will be and the more frequently\n *    we will recalculate the % of traffic we should be shedding. This check\n *    is rather lightweight, while the default is 250ms, you should be able to\n *    decrease this value without seeing a significant impact to performance.\n * @param {Number} [opts.halfLife] - When we sample the CPU usage on an\n *    interval, we create a series of data points.\n *    We take these points and calculate a\n *    moving average. The halfLife indicates how quickly a point \"decays\" to\n *    half it's value in the moving average. The lower the halfLife, the more\n *    impact newer data points have on the average. If you want to be extremely\n *    responsive to spikes in CPU usage, set this to a lower value. If you want\n *    your process to put more emphasis on recent historical CPU usage when\n *    determininng whether it should shed load, set this to a higher value. The\n *    unit is in ms. Defaults to 250.\n * @returns {Function} middleware to be registered on server.pre\n * @example\n * var restify = require('restify');\n *\n * var server = restify.createServer();\n * const options = {\n *   limit: .75,\n *   max: 1,\n *   interval: 250,\n *   halfLife: 500,\n * }\n *\n * server.pre(restify.plugins.cpuUsageThrottle(options));\n * @example\n * <caption>\n * You can also update the plugin during runtime using the `.update()` function.\n * This function accepts the same `opts` object as a constructor.\n * </caption>\n * var plugin = restify.plugins.cpuUsageThrottle(options);\n * server.pre(plugin);\n *\n * plugin.update({ limit: .4, halfLife: 5000 });\n */\n\n\nfunction cpuUsageThrottlePlugin(opts) {\n  // Scrub input and populate our configuration\n  assert.object(opts, 'opts');\n  assert.optionalNumber(opts.limit, 'opts.limit');\n  assert.optionalNumber(opts.max, 'opts.max');\n  assert.optionalNumber(opts.interval, 'opts.interval');\n  assert.optionalNumber(opts.halfLife, 'opts.halfLife');\n  var plugin = {};\n  plugin._limit = typeof opts.limit === 'number' ? opts.limit : 0.75;\n  plugin._max = opts.max || 1;\n  plugin._interval = opts.interval || 250;\n  plugin._halfLife = typeof opts.halfLife === 'number' ? opts.halfLife : 250;\n  assert.ok(plugin._max > plugin._limit, 'limit must be less than max');\n  plugin._ewma = new EWMA(plugin._halfLife); // plugin._reject represents the % of traffic that we should reject at the\n  // current point in time based on how much over our limit we are. This is\n  // updated on an interval by updateReject().\n\n  plugin._reject = 0; // plugin._timeout keeps track of the current handle for the setTimeout we\n  // use to gather CPU load averages, this allows us to cancel the timeout\n  // when shutting down restify.\n\n  plugin._timeout = null; // plugin._timeoutDelta represents the amount of time between when we\n  // _should_ have run updateReject and the actual time it was invoked.\n  // This allows us to monitor lag caused by both the event loop\n  // and pidusage\n\n  plugin._timeoutDelta = 0;\n  plugin._timeoutStart = Date.now(); // updateReject should be called on an interval, it checks the average CPU\n  // usage between two invocations of updateReject.\n\n  function updateReject() {\n    pidusage(process.pid, function pidusageStat(e, stat) {\n      // Requeue an updateReject irrespective of whether or not pidusage\n      // encountered an error\n      plugin._timeout = setTimeout(updateReject, plugin._interval); // If we were unable to get cpu usage, don't make any new decisions.\n\n      if (!stat || typeof stat.cpu !== 'number' || Number.isNaN(stat.cpu)) {\n        return;\n      } // Divide by 100 to match Linux's `top` format\n\n\n      plugin._ewma.insert(stat.cpu / 100);\n\n      plugin._cpu = plugin._ewma.value(); // Update reject with the % of traffic we should be rejecting. This\n      // is safe since max > limit so the denominator can never be 0. If\n      // the current cpu usage is less that the limit, _reject will be\n      // negative and we will never shed load\n\n      plugin._reject = (plugin._cpu - plugin._limit) / (plugin._max - plugin._limit); // Calculate how long it took between when our interval should have\n      // updated the _reject value and how long it actually took. This\n      // metric accounts for the misbehaviour of pidusage\n\n      var now = Date.now();\n      plugin._timeoutDelta = now - plugin._timeoutStart - plugin._interval;\n      plugin._timeoutStart = now;\n    });\n  } // Kick off updating our _reject value\n\n\n  updateReject();\n\n  function cpuUsageThrottle(req, res, next) {\n    // Check to see if this request gets rejected. Since, in updateReject,\n    // we calculate a percentage of traffic we are planning to reject, we\n    // can use Math.random() (which picks from a uniform distribution in\n    // [0,1)) to give us a `plugin._reject`% chance of dropping any given\n    // request. This is a stateless was to drop approximatly\n    // `plugin._reject`% of traffic.\n    var probabilityDraw = Math.random();\n\n    if (probabilityDraw >= plugin._reject) {\n      return next(); // Don't reject this request\n    }\n\n    var err = new errors.ServiceUnavailableError({\n      context: {\n        plugin: 'cpuUsageThrottle',\n        cpuUsage: plugin._cpu,\n        limit: plugin._limit,\n        max: plugin._max,\n        reject: plugin._reject,\n        halfLife: plugin._halfLife,\n        interval: plugin._interval,\n        probabilityDraw: probabilityDraw,\n        lag: plugin._timeoutDelta\n      }\n    });\n    return next(err);\n  } // Allow the app to clear the timeout for this plugin if necessary, without\n  // this we would never be able to clear the event loop when letting Node\n  // shut down gracefully\n\n\n  function close() {\n    clearTimeout(plugin._timeout);\n  }\n\n  cpuUsageThrottle.close = close; // Expose internal plugin state for introspection\n\n  Object.defineProperty(cpuUsageThrottle, 'state', {\n    get: function get() {\n      // We intentionally do not expose ewma since we don't want the user\n      // to be able to update it's configuration, the current state of\n      // ewma is represented in plugin._cpu\n      return {\n        limit: plugin._limit,\n        max: plugin._max,\n        interval: plugin._interval,\n        halfLife: plugin._halfLife,\n        cpuUsage: plugin._cpu,\n        reject: plugin._reject,\n        lag: plugin._timeoutDelta\n      };\n    }\n  });\n  /**\n   * cpuUsageThrottle.update\n   *\n   * Allow the plugin's configuration to be updated during runtime.\n   *\n   * @private\n   * @param {Object} newOpts - The opts object for reconfiguring this plugin,\n   *    it follows the same format as the constructor for this plugin.\n   * @returns {undefined} no return value\n   */\n\n  cpuUsageThrottle.update = function update(newOpts) {\n    assert.object(newOpts, 'newOpts');\n    assert.optionalNumber(newOpts.limit, 'newOpts.limit');\n    assert.optionalNumber(newOpts.max, 'newOpts.max');\n    assert.optionalNumber(newOpts.interval, 'newOpts.interval');\n    assert.optionalNumber(newOpts.halfLife, 'newOpts.halfLife');\n\n    if (newOpts.limit !== undefined) {\n      plugin._limit = newOpts.limit;\n    }\n\n    if (newOpts.max !== undefined) {\n      plugin._max = newOpts.max;\n    }\n\n    if (newOpts.interval !== undefined) {\n      plugin._interval = newOpts.interval;\n    }\n\n    if (newOpts.halfLife !== undefined) {\n      plugin._halfLife = newOpts.halfLife; // update our ewma with the new halfLife, we use the previous known\n      // state as the initial state for our new halfLife in lieu of\n      // having access to true historical data.\n\n      plugin._ewma = new EWMA(plugin._halfLife, plugin._cpu);\n    } // Ensure new values are still valid\n\n\n    assert.ok(plugin._max > plugin._limit, 'limit must be less than max'); // Update _reject with the new settings\n\n    plugin._reject = (plugin._cpu - plugin._limit) / (plugin._max - plugin._limit);\n  };\n\n  return cpuUsageThrottle;\n}\n\nmodule.exports = cpuUsageThrottlePlugin;","map":null,"metadata":{},"sourceType":"script"}