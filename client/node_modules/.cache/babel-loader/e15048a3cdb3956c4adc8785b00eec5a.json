{"ast":null,"code":"'use strict';\n\nvar assert = require('assert-plus');\n\nvar hrTimeDurationInMs = require('./utils/hrTimeDurationInMs');\n/**\n * Timing internals\n *\n * Timings are also saved when there is no handler in the given category.\n * Some handler categories are optional, for example there is no\n * `use` and `route` for 404.\n *\n * @private\n *\n * req._timeStart      - request lifecycle started in restify\n * req._timePreStart   - pre handlers started\n * req._timePreEnd     - all pre handlers finished\n * req._timeUseStart   - use handlers started\n * req._timeUseEnd     - all use handlers finished\n * req._timeRouteStart - route handlers started\n * req._timeRouteEnd   - all route handlers finished\n * req._timeFlushed    - request flushed, may happens before handlers finished\n * req._timeFinished   - both all handlers finished and request flushed\n */\n///--- API\n\n/**\n * The module includes the following plugins to be used with restify's `after`\n * event, e.g., `server.on('after', restify.plugins.metrics());`:\n *\n * A plugin that listens to the server's after event and emits information\n * about that request.\n *\n * @public\n * @function metrics\n * @param {Object} opts - an options obj\n * @param {Server} opts.server - restify server\n * @param {createMetrics~callback} callback - a callback fn\n * @returns {Function} returns a function suitable to be used\n *   with restify server's `after` event\n * @example\n * server.on('after', restify.plugins.metrics({ server: server },\n *     function (err, metrics, req, res, route) {\n *         // metrics is an object containing information about the request\n * }));\n */\n\n\nfunction createMetrics(opts, callback) {\n  assert.object(opts, 'opts');\n  assert.object(opts.server, 'opts.server');\n  assert.func(callback, 'callback');\n  return function metrics(req, res, route, err) {\n    var data = {\n      // response status code. in most cases this should be a proper\n      // http status code, but in the case of an uncaughtException it can\n      // be undefined. otherwise, in most normal scenarios, even calling\n      // res.send() or res.end() should result in a 200 by default.\n      statusCode: res.statusCode,\n      // REST verb\n      method: req.method,\n      // overall request latency\n      totalLatency: hrTimeDurationInMs(req._timeStart, req._timeFinished),\n      latency: hrTimeDurationInMs(req._timeStart, req._timeFlushed),\n      preLatency: hrTimeDurationInMs(req._timePreStart, req._timePreEnd),\n      useLatency: hrTimeDurationInMs(req._timeUseStart, req._timeUseEnd),\n      routeLatency: hrTimeDurationInMs(req._timeRouteStart, req._timeRouteEnd),\n      // the cleaned up url path\n      // e.g., /foo?a=1 => /foo\n      path: req.path(),\n      // connection state can currently only have the following values:\n      // 'close' | undefined.\n      //\n      // if the connection state is 'close'\n      // the status code will be set to 444\n      // it is possible to get a 200 statusCode with a connectionState\n      // value of 'close'. i.e., the client timed out,\n      // but restify thinks it \"sent\" a response. connectionState should\n      // always be the primary source of truth here, and check it first\n      // before consuming statusCode. otherwise, it may result in skewed\n      // metrics.\n      connectionState: req.connectionState && req.connectionState(),\n      unfinishedRequests: opts.server.inflightRequests && opts.server.inflightRequests(),\n      inflightRequests: opts.server.inflightRequests && opts.server.inflightRequests()\n    };\n    return callback(err, data, req, res, route);\n  };\n}\n/**\n * Callback used by metrics plugin\n * @callback metrics~callback\n * @param {Error} err\n * @param {Object} metrics - metrics about the request\n * @param {Number} metrics.statusCode status code of the response. can be\n *   undefined in the case of an uncaughtException\n * @param {String} metrics.method http request verb\n * @param {Number} metrics.totalLatency latency includes both request is flushed\n *                                      and all handlers finished\n * @param {Number} metrics.latency latency when request is flushed\n * @param {Number|null} metrics.preLatency pre handlers latency\n * @param {Number|null} metrics.useLatency use handlers latency\n * @param {Number|null} metrics.routeLatency route handlers latency\n * @param {String} metrics.path `req.path()` value\n * @param {Number} metrics.inflightRequests Number of inflight requests pending\n *   in restify.\n * @param {Number} metrics.unifinishedRequests Same as `inflightRequests`\n * @param {String} metrics.connectionState can be either `'close'` or\n *  `undefined`. If this value is set, err will be a\n *   corresponding `RequestCloseError`.\n *   If connectionState is either\n *   `'close'`, then the `statusCode` is not applicable since the\n *   connection was severed before a response was written.\n * @param {Request} req the request obj\n * @param {Response} res the response obj\n * @param {Route} route the route obj that serviced the request\n */\n///-- Exports\n\n\nmodule.exports = createMetrics;","map":null,"metadata":{},"sourceType":"script"}