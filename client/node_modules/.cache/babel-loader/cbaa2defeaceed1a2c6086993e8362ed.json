{"ast":null,"code":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n'use strict';\n\nvar domain = require('domain');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar util = require('util');\n\nvar _ = require('lodash');\n\nvar assert = require('assert-plus');\n\nvar errors = require('restify-errors');\n\nvar mime = require('mime');\n\nvar spdy = require('spdy');\n\nvar vasync = require('vasync');\n\nvar Chain = require('./chain');\n\nvar dtrace = require('./dtrace');\n\nvar formatters = require('./formatters');\n\nvar shallowCopy = require('./utils').shallowCopy;\n\nvar upgrade = require('./upgrade');\n\nvar deprecationWarnings = require('./deprecationWarnings');\n\nvar customErrorTypes = require('./errorTypes'); // Ensure these are loaded\n\n\nvar patchRequest = require('./request');\n\nvar patchResponse = require('./response');\n\nvar http2;\npatchResponse(http.ServerResponse);\npatchRequest(http.IncomingMessage); ///--- Globals\n\nvar sprintf = util.format; ///--- API\n\n/**\n * Creates a new Server.\n *\n * @public\n * @class\n * @param {Object} options  - an options object\n * @param {String} options.name - Name of the server.\n * @param {Boolean} [options.dtrace=false] - enable DTrace support\n * @param {Router} options.router - Router\n * @param {Object} options.log - [bunyan](https://github.com/trentm/node-bunyan)\n * instance.\n * @param {String} [options.url] - Once listen() is called, this will be filled\n * in with where the server is running.\n * @param {String|Buffer} [options.certificate] - If you want to create an HTTPS\n * server, pass in a PEM-encoded certificate and key.\n * @param {String|Buffer} [options.key] - If you want to create an HTTPS server,\n * pass in a PEM-encoded certificate and key.\n * @param {Object} [options.formatters] - Custom response formatters for\n * `res.send()`.\n * @param {Boolean} [options.handleUncaughtExceptions=false] - When true restify\n * will use a domain to catch and respond to any uncaught\n * exceptions that occur in it's handler stack.\n * Comes with significant negative performance impact.\n * [bunyan](https://github.com/trentm/node-bunyan) instance.\n * response header, default is `restify`. Pass empty string to unset the header.\n * @param {Object} [options.spdy] - Any options accepted by\n * [node-spdy](https://github.com/indutny/node-spdy).\n * @param {Object} [options.http2] - Any options accepted by\n * [http2.createSecureServer](https://nodejs.org/api/http2.html).\n * @param {Boolean} [options.handleUpgrades=false] - Hook the `upgrade` event\n * from the node HTTP server, pushing `Connection: Upgrade` requests through the\n *  regular request handling chain.\n * @param {Boolean} [options.onceNext=false] - Prevents calling next multiple\n *  times\n * @param {Boolean} [options.strictNext=false] - Throws error when next() is\n *  called more than once, enabled onceNext option\n * @param {Object} [options.httpsServerOptions] - Any options accepted by\n * [node-https Server](http://nodejs.org/api/https.html#https_https).\n * If provided the following restify server options will be ignored:\n * spdy, ca, certificate, key, passphrase, rejectUnauthorized, requestCert and\n * ciphers; however these can all be specified on httpsServerOptions.\n * @param {Boolean} [options.noWriteContinue=false] - prevents\n *  `res.writeContinue()` in `server.on('checkContinue')` when proxing\n * @param {Boolean} [options.ignoreTrailingSlash=false] - ignore trailing slash\n * on paths\n * @param {Boolean} [options.strictFormatters=true] - enables strict formatters\n * behavior: a formatter matching the response's content-type is required. If\n * not found, the response's content-type is automatically set to\n * 'application/octet-stream'. If a formatter for that content-type is not\n * found, sending the response errors.\n * @example\n * var restify = require('restify');\n * var server = restify.createServer();\n *\n * server.listen(8080, function () {\n *   console.log('ready on %s', server.url);\n * });\n */\n\nfunction Server(options) {\n  assert.object(options, 'options');\n  assert.object(options.log, 'options.log');\n  assert.object(options.router, 'options.router');\n  assert.string(options.name, 'options.name');\n  assert.optionalBool(options.handleUncaughtExceptions, 'options.handleUncaughtExceptions');\n  assert.optionalBool(options.dtrace, 'options.dtrace');\n  assert.optionalBool(options.socketio, 'options.socketio');\n  assert.optionalBool(options.onceNext, 'options.onceNext');\n  assert.optionalBool(options.strictNext, 'options.strictNext');\n  assert.optionalBool(options.strictFormatters, 'options.strictFormatters');\n  var self = this;\n  EventEmitter.call(this);\n  this.onceNext = !!options.onceNext;\n  this.strictNext = !!options.strictNext;\n  this.firstChain = [];\n  this.preChain = new Chain({\n    onceNext: this.onceNext,\n    strictNext: this.strictNext\n  });\n  this.useChain = new Chain({\n    onceNext: this.onceNext,\n    strictNext: this.strictNext\n  });\n  this.log = options.log;\n  this.name = options.name;\n  this.handleUncaughtExceptions = options.handleUncaughtExceptions || false;\n  this.router = options.router;\n  this.secure = false;\n  this.socketio = options.socketio || false;\n  this.dtrace = options.dtrace || false;\n  this._inflightRequests = 0;\n  this.strictFormatters = true;\n\n  if (options.strictFormatters !== undefined) {\n    this.strictFormatters = options.strictFormatters;\n  }\n\n  var fmt = mergeFormatters(options.formatters);\n  this.acceptable = fmt.acceptable;\n  this.formatters = fmt.formatters;\n  this.proxyEvents = ['clientError', 'close', 'connection', 'error', 'listening', 'secureConnection'];\n\n  if (options.spdy) {\n    this.spdy = true;\n    this.server = spdy.createServer(options.spdy);\n  } else if (options.http2) {\n    // http2 module is not available < v8.4.0 (only with flag <= 8.8.0)\n    // load http2 module here to avoid experimental warning in other cases\n    if (!http2) {\n      try {\n        http2 = require('http2');\n        patchResponse(http2.Http2ServerResponse);\n        patchRequest(http2.Http2ServerRequest); // eslint-disable-next-line no-empty\n      } catch (err) {}\n    }\n\n    assert(http2, 'http2 module is not available, ' + 'upgrade your Node.js version to >= 8.8.0');\n    this.http2 = true;\n    this.server = http2.createSecureServer(options.http2);\n  } else if ((options.cert || options.certificate) && options.key) {\n    this.ca = options.ca;\n    this.certificate = options.certificate || options.cert;\n    this.key = options.key;\n    this.passphrase = options.passphrase || null;\n    this.secure = true;\n    this.server = https.createServer({\n      ca: self.ca,\n      cert: self.certificate,\n      key: self.key,\n      passphrase: self.passphrase,\n      rejectUnauthorized: options.rejectUnauthorized,\n      requestCert: options.requestCert,\n      ciphers: options.ciphers,\n      secureOptions: options.secureOptions\n    });\n  } else if (options.httpsServerOptions) {\n    this.server = https.createServer(options.httpsServerOptions);\n  } else {\n    this.server = http.createServer();\n  }\n\n  this.router.on('mount', this.emit.bind(this, 'mount'));\n\n  if (!options.handleUpgrades) {\n    this.proxyEvents.push('upgrade');\n  }\n\n  this.proxyEvents.forEach(function forEach(e) {\n    self.server.on(e, self.emit.bind(self, e));\n  }); // Now the things we can't blindly proxy\n\n  this.server.on('checkContinue', function onCheckContinue(req, res) {\n    if (self.listeners('checkContinue').length > 0) {\n      self.emit('checkContinue', req, res);\n      return;\n    }\n\n    if (!options.noWriteContinue) {\n      res.writeContinue();\n    }\n\n    self._onRequest(req, res);\n  });\n\n  if (options.handleUpgrades) {\n    this.server.on('upgrade', function onUpgrade(req, socket, head) {\n      req._upgradeRequest = true;\n      var res = upgrade.createResponse(req, socket, head);\n\n      self._onRequest(req, res);\n    });\n  }\n\n  this.server.on('request', this._onRequest.bind(this));\n\n  this.__defineGetter__('maxHeadersCount', function getMaxHeadersCount() {\n    return self.server.maxHeadersCount;\n  });\n\n  this.__defineSetter__('maxHeadersCount', function setMaxHeadersCount(c) {\n    self.server.maxHeadersCount = c;\n    return c;\n  });\n\n  this.__defineGetter__('url', function getUrl() {\n    if (self.socketPath) {\n      return 'http://' + self.socketPath;\n    }\n\n    var addr = self.address();\n    var str = '';\n\n    if (self.spdy) {\n      str += 'spdy://';\n    } else if (self.secure) {\n      str += 'https://';\n    } else {\n      str += 'http://';\n    }\n\n    if (addr) {\n      str += addr.family === 'IPv6' ? '[' + addr.address + ']' : addr.address;\n      str += ':';\n      str += addr.port;\n    } else {\n      str += '169.254.0.1:0000';\n    }\n\n    return str;\n  }); // print deprecation messages based on server configuration\n\n\n  deprecationWarnings(self);\n}\n\nutil.inherits(Server, EventEmitter);\nmodule.exports = Server; ///--- Server lifecycle methods\n// eslint-disable-next-line jsdoc/check-param-names\n\n/**\n * Gets the server up and listening.\n * Wraps node's\n * [listen()](\n * http://nodejs.org/docs/latest/api/net.html#net_server_listen_path_callback).\n *\n * @public\n * @memberof Server\n * @instance\n * @function   listen\n * @throws   {TypeError}\n * @param    {Number} port - Port\n * @param    {Number} [host] - Host\n * @param    {Function} [callback] - optionally get notified when listening.\n * @returns  {undefined} no return value\n * @example\n * <caption>You can call like:</caption>\n * server.listen(80)\n * server.listen(80, '127.0.0.1')\n * server.listen('/tmp/server.sock')\n */\n\nServer.prototype.listen = function listen() {\n  var args = Array.prototype.slice.call(arguments);\n  return this.server.listen.apply(this.server, args);\n};\n/**\n * Shuts down this server, and invokes callback (optionally) when done.\n * Wraps node's\n * [close()](http://nodejs.org/docs/latest/api/net.html#net_event_close).\n *\n * @public\n * @memberof Server\n * @instance\n * @function   close\n * @param    {Function}  [callback] - callback to invoke when done\n * @returns  {undefined} no return value\n */\n\n\nServer.prototype.close = function close(callback) {\n  if (callback) {\n    assert.func(callback, 'callback');\n  }\n\n  this.server.once('close', function onClose() {\n    return callback ? callback() : false;\n  });\n  return this.server.close();\n}; ///--- Routing methods\n\n/**\n * Server method opts\n * @typedef  {String|Regexp |Object} Server~methodOpts\n * @type     {Object}\n * @property {String} name a name for the route\n * @property {String} path can be any String accepted by\n * [find-my-way](https://github.com/delvedor/find-my-way)\n * @example\n * // a static route\n * server.get('/foo', function(req, res, next) {});\n * // a parameterized route\n * server.get('/foo/:bar', function(req, res, next) {});\n * // a regular expression\n * server.get('/example/:file(^\\\\d+).png', function(req, res, next) {});\n * // an options object\n * server.get({\n *     path: '/foo',\n * }, function(req, res, next) {});\n */\n\n/**\n * Mounts a chain on the given path against this HTTP verb\n *\n * @public\n * @memberof Server\n * @instance\n * @function get\n * @param   {Server~methodOpts} opts - if string, the URL to handle.\n *                                 if options, the URL to handle, at minimum.\n * @returns {Route}                the newly created route.\n * @example\n * server.get('/', function (req, res, next) {\n *    res.send({ hello: 'world' });\n *    next();\n * });\n */\n\n\nServer.prototype.get = serverMethodFactory('GET');\n/**\n * Mounts a chain on the given path against this HTTP verb\n *\n * @public\n * @memberof Server\n * @instance\n * @function head\n * @param   {Server~methodOpts} opts - if string, the URL to handle.\n *                                 if options, the URL to handle, at minimum.\n * @returns {Route}                the newly created route.\n */\n\nServer.prototype.head = serverMethodFactory('HEAD');\n/**\n * Mounts a chain on the given path against this HTTP verb\n *\n * @public\n * @memberof Server\n * @instance\n * @function post\n * @param   {Server~methodOpts} post - if string, the URL to handle.\n *                                 if options, the URL to handle, at minimum.\n * @returns {Route}                the newly created route.\n */\n\nServer.prototype.post = serverMethodFactory('POST');\n/**\n * Mounts a chain on the given path against this HTTP verb\n *\n * @public\n * @memberof Server\n * @instance\n * @function put\n * @param   {Server~methodOpts} put - if string, the URL to handle.\n *                                 if options, the URL to handle, at minimum.\n * @returns {Route}                the newly created route.\n */\n\nServer.prototype.put = serverMethodFactory('PUT');\n/**\n * Mounts a chain on the given path against this HTTP verb\n *\n * @public\n * @memberof Server\n * @instance\n * @function patch\n * @param   {Server~methodOpts} patch - if string, the URL to handle.\n *                                 if options, the URL to handle, at minimum.\n * @returns {Route}                the newly created route.\n */\n\nServer.prototype.patch = serverMethodFactory('PATCH');\n/**\n * Mounts a chain on the given path against this HTTP verb\n *\n * @public\n * @memberof Server\n * @instance\n * @function del\n * @param   {Server~methodOpts} opts - if string, the URL to handle.\n *                                 if options, the URL to handle, at minimum.\n * @returns {Route}                the newly created route.\n */\n\nServer.prototype.del = serverMethodFactory('DELETE');\n/**\n * Mounts a chain on the given path against this HTTP verb\n *\n * @public\n * @memberof Server\n * @instance\n * @function opts\n * @param   {Server~methodOpts} opts - if string, the URL to handle.\n *                                 if options, the URL to handle, at minimum.\n * @returns {Route}                the newly created route.\n */\n\nServer.prototype.opts = serverMethodFactory('OPTIONS'); ///---  Request lifecycle and middleware methods\n// eslint-disable-next-line jsdoc/check-param-names\n\n/**\n * Gives you hooks to run _before_ any routes are located.  This gives you\n * a chance to intercept the request and change headers, etc., that routing\n * depends on.  Note that req.params will _not_ be set yet.\n *\n * @public\n * @memberof Server\n * @instance\n * @function pre\n * @param {...Function|Array} handler - Allows you to add handlers that\n * run for all routes. *before* routing occurs.\n * This gives you a hook to change request headers and the like if you need to.\n * Note that `req.params` will be undefined, as that's filled in *after*\n * routing.\n * Takes a function, or an array of functions.\n * variable number of nested arrays of handler functions\n * @returns {Object} returns self\n * @example\n * server.pre(function(req, res, next) {\n *   req.headers.accept = 'application/json';\n *   return next();\n * });\n * @example\n * <caption>For example, `pre()` can be used to deduplicate slashes in\n * URLs</caption>\n * server.pre(restify.pre.dedupeSlashes());\n */\n\nServer.prototype.pre = function pre() {\n  var self = this;\n  var handlers = Array.prototype.slice.call(arguments);\n  argumentsToChain(handlers).forEach(function forEach(handler) {\n    handler._name = handler.name || 'pre-' + self.preChain.count();\n    self.preChain.add(handler);\n  });\n  return this;\n}; // eslint-disable-next-line jsdoc/check-param-names\n\n/**\n * Gives you hooks that run before restify touches a request. These hooks\n * allow you to do processing early in the request/response life cycle without\n * the overhead of the restify framework. You can not yield the event loop in\n * this handler.\n *\n * The function handler accepts two parameters: req, res. If you want restify\n * to ignore this request, return false from your handler. Return true or\n * undefined to let restify continue handling the request.\n *\n * When false is returned, restify immediately stops handling the request. This\n * means that no further middleware will be executed for any chain and routing\n * will not occure. All request/response handling for an incoming request must\n * be done inside the first handler if you intend to return false. This\n * includes things like closing the response and returning a status code.\n *\n * The only work restify does for a first handler is to increment the number of\n * inflightRequests prior to calling the chain, and decrement that value if the\n * handler returns false. Returning anything other than true, false, undefined,\n * or null will cause an exception to be thrown.\n *\n * Since server.first is designed to bypass the restify framework, there are\n * naturally trade-offs you make when using this API:\n *  * Standard restify lifecycle events such as 'after' are not triggered for\n *    any request that you return false from a handler for\n *  * Invoking any of the restify req/res APIs from within a first handler is\n *    unspecified behavior, as the restify framework hasn't built up state for\n *    the request yet.\n *  * There are no request timers available at the time that the first chain\n *    runs.\n *  * And more! Beware doing anything with restify in these handlers. They are\n *    designed to give you similar access to the req/res as you would have if\n *    you were directly using node.js' http module, they are outside of the\n *    restify framework!\n *\n * @public\n * @memberof Server\n * @instance\n * @function first\n * @param {...Function} handler - Allows you to add handlers that\n * run for all requests, *before* restify touches the request.\n * This gives you a hook to change request headers and the like if you need to.\n * Note that `req.params` will be undefined, as that's filled in *after*\n * routing.\n\n * Takes one or more functions.\n * @returns {Object} returns self\n * @example\n * server.first(function(req, res) {\n *   if(server.inflightRequests() > 100) {\n *     res.statusCode = 503;\n *     res.end();\n *     return false\n *   }\n *   return true;\n * })\n */\n\n\nServer.prototype.first = function first() {\n  var args = Array.prototype.slice.call(arguments);\n\n  for (var i = 0; i < args.length; i++) {\n    assert.func(args[i]);\n    this.firstChain.push(args[i]);\n  }\n\n  return this;\n}; // eslint-disable-next-line jsdoc/check-param-names\n\n/**\n * Allows you to add in handlers that run for all routes. Note that handlers\n * added\n * via `use()` will run only after the router has found a matching route. If no\n * match is found, these handlers will never run. Takes a function, or an array\n * of functions.\n *\n * You can pass in any combination of functions or array of functions.\n *\n * @public\n * @memberof Server\n * @instance\n * @function use\n * @param {...Function|Array} handler - A variable number of handler functions\n * * and/or a\n * variable number of nested arrays of handler functions\n * @returns {Object} returns self\n */\n\n\nServer.prototype.use = function use() {\n  var self = this;\n  var handlers = Array.prototype.slice.call(arguments);\n  argumentsToChain(handlers).forEach(function forEach(handler) {\n    handler._name = handler.name || 'use-' + self.useChain.count();\n    self.useChain.add(handler);\n  });\n  return this;\n};\n/**\n * Minimal port of the functionality offered by Express.js Route Param\n * Pre-conditions\n *\n * This basically piggy-backs on the `server.use` method. It attaches a\n * new middleware function that only fires if the specified parameter exists\n * in req.params\n *\n * Exposes an API:\n *   server.param(\"user\", function (req, res, next) {\n *     // load the user's information here, always making sure to call next()\n *   });\n *\n * @see http://expressjs.com/guide.html#route-param%20pre-conditions\n * @public\n * @memberof Server\n * @instance\n * @function param\n * @param    {String}   name - The name of the URL param to respond to\n * @param    {Function} fn -   The middleware function to execute\n * @returns  {Object}        returns self\n */\n\n\nServer.prototype.param = function param(name, fn) {\n  this.use(function _param(req, res, next) {\n    if (req.params && req.params.hasOwnProperty(name)) {\n      fn.call(this, req, res, next, req.params[name], name);\n    } else {\n      next();\n    }\n  });\n  return this;\n};\n/**\n * Removes a route from the server.\n * You pass in the route 'blob' you got from a mount call.\n *\n * @public\n * @memberof Server\n * @instance\n * @function rm\n * @throws   {TypeError} on bad input.\n * @param    {String}    routeName - the route name.\n * @returns  {Boolean}   true if route was removed, false if not.\n */\n\n\nServer.prototype.rm = function rm(routeName) {\n  var route = this.router.unmount(routeName);\n  return !!route;\n}; ///--- Info and debug methods\n\n/**\n * Returns the server address.\n * Wraps node's\n * [address()](http://nodejs.org/docs/latest/api/net.html#net_server_address).\n *\n * @public\n * @memberof Server\n * @instance\n * @function address\n * @returns  {Object} Address of server\n * @example\n * server.address()\n * @example\n * <caption>Output:</caption>\n * { address: '::', family: 'IPv6', port: 8080 }\n */\n\n\nServer.prototype.address = function address() {\n  return this.server.address();\n};\n/**\n * Returns the number of inflight requests currently being handled by the server\n *\n * @public\n * @memberof Server\n * @instance\n * @function inflightRequests\n * @returns  {number} number of inflight requests\n */\n\n\nServer.prototype.inflightRequests = function inflightRequests() {\n  var self = this;\n  return self._inflightRequests;\n};\n/**\n * Return debug information about the server.\n *\n * @public\n * @memberof Server\n * @instance\n * @function debugInfo\n * @returns {Object} debug info\n * @example\n * server.getDebugInfo()\n * @example\n * <caption>Output:</caption>\n * {\n *   routes: [\n *     {\n *       name: 'get',\n *       method: 'get',\n *       input: '/',\n *       compiledRegex: /^[\\/]*$/,\n *       compiledUrlParams: null,\n *       handlers: [Array]\n *      }\n *   ],\n *   server: {\n *     formatters: {\n *       'application/javascript': [Function: formatJSONP],\n *       'application/json': [Function: formatJSON],\n *       'text/plain': [Function: formatText],\n *       'application/octet-stream': [Function: formatBinary]\n *     },\n *     address: '::',\n *     port: 8080,\n *     inflightRequests: 0,\n *     pre: [],\n *     use: [ 'parseQueryString', '_jsonp' ],\n *     after: []\n *   }\n * }\n */\n\n\nServer.prototype.getDebugInfo = function getDebugInfo() {\n  var self = this; // map an array of function to an array of function names\n\n  var funcNameMapper = function funcNameMapper(handler) {\n    if (handler.name === '') {\n      return 'anonymous';\n    } else {\n      return handler.name;\n    }\n  };\n\n  if (!self._debugInfo) {\n    var addressInfo = self.server.address(); // output the actual routes registered with restify\n\n    var routeInfo = self.router.getDebugInfo();\n    var preHandlers = self.preChain.getHandlers().map(funcNameMapper);\n    var useHandlers = self.useChain.getHandlers().map(funcNameMapper); // get each route's handler chain\n\n    var routes = _.map(routeInfo, function mapValues(route) {\n      route.handlers = Array.prototype.concat.call( // TODO: should it contain use handlers?\n      useHandlers, route.handlers.map(funcNameMapper));\n      return route;\n    });\n\n    self._debugInfo = {\n      routes: routes,\n      server: {\n        formatters: self.formatters,\n        // if server is not yet listening, addressInfo may be null\n        address: addressInfo && addressInfo.address,\n        port: addressInfo && addressInfo.port,\n        inflightRequests: self.inflightRequests(),\n        pre: preHandlers,\n        use: useHandlers,\n        after: self.listeners('after').map(funcNameMapper)\n      }\n    };\n  }\n\n  return self._debugInfo;\n};\n/**\n * toString() the server for easy reading/output.\n *\n * @public\n * @memberof Server\n * @instance\n * @function toString\n * @returns  {String} stringified server\n * @example\n * server.toString()\n * @example\n * <caption>Output:</caption>\n *\tAccepts: application/json, text/plain, application/octet-stream,\n * application/javascript\n *\tName: restify\n *\tPre: []\n *\tRouter: RestifyRouter:\n *\t\tDELETE: []\n *\t\tGET: [get]\n *\t\tHEAD: []\n *\t\tOPTIONS: []\n *\t\tPATCH: []\n *\t\tPOST: []\n *\t\tPUT: []\n *\n *\tRoutes:\n *\t\tget: [parseQueryString, _jsonp, function]\n *\tSecure: false\n *\tUrl: http://[::]:8080\n *\tVersion:\n */\n\n\nServer.prototype.toString = function toString() {\n  var LINE_FMT = '\\t%s: %s\\n';\n  var SUB_LINE_FMT = '\\t\\t%s: %s\\n';\n  var str = '';\n\n  function handlersToString(arr) {\n    var s = '[' + arr.map(function map(b) {\n      return b.name || 'function';\n    }).join(', ') + ']';\n    return s;\n  }\n\n  str += sprintf(LINE_FMT, 'Accepts', this.acceptable.join(', '));\n  str += sprintf(LINE_FMT, 'Name', this.name);\n  str += sprintf(LINE_FMT, 'Pre', handlersToString(this.preChain.getHandlers()));\n  str += sprintf(LINE_FMT, 'Router', '');\n  this.router.toString().split('\\n').forEach(function forEach(line) {\n    str += sprintf('\\t\\t%s\\n', line);\n  });\n  str += sprintf(LINE_FMT, 'Routes', '');\n\n  _.forEach(this.router.getRoutes(), function forEach(route, routeName) {\n    var handlers = handlersToString(route.chain.getHandlers());\n    str += sprintf(SUB_LINE_FMT, routeName, handlers);\n  });\n\n  str += sprintf(LINE_FMT, 'Secure', this.secure);\n  str += sprintf(LINE_FMT, 'Url', this.url);\n  return str;\n}; ///--- Private methods\n// Lifecycle:\n//\n// 1. _onRequest (handle new request, setup request and triggers pre)\n//   2. _runPre\n//     3. _afterPre (runs after pre handlers are finisehd, triggers route)\n//       4. _runRoute (route lookup)\n//         5. _runUse (runs use handlers, if route exists)\n//            6. Runs route handlers\n//              7. _afterRoute (runs after route handlers are finised,\n//                          triggers use)\n// 8. _finishReqResCycle (on response \"finish\" and \"error\" events)\n//\n// Events:\n// e.1 after (triggered when response is flushed)\n//\n// Errors:\n// e.1 _onHandlerError (runs when next was called with an Error)\n//   e.2 _routeErrorResponse\n// e.1 _onHandlerError (when, next('string') called, trigger route by name)\n//  e.2 _afterRoute\n\n/**\n * Setup request and calls _onRequest to run middlewares and call router\n *\n * @private\n * @memberof Server\n * @instance\n * @function _onRequest\n * @param    {Object}    req - the request object\n * @param    {Object}    res - the response object\n * @returns  {undefined} no return value\n * @fires Request,Response#request\n */\n\n\nServer.prototype._onRequest = function _onRequest(req, res) {\n  var self = this; // Increment the number of inflight requests prior to calling the firstChain\n  // handlers. This accomplishes two things. First, it gives earliest an\n  // accurate count of how many inflight requests there would be including\n  // this new request. Second, it intentionally winds up the inflight request\n  // accounting with the implementation of firstChain. Note how we increment\n  // here, but decrement down inside the for loop below. It's easy to end up\n  // with race conditions betwen inflight request accounting and inflight\n  // request load shedding, causing load shedding to reject/allow too many\n  // requests. The current implementation of firstChain is designed to\n  // remove those race conditions. By winding these implementations up with\n  // one another, it makes it clear that moving around the inflight request\n  // accounting will change the behavior of earliest.\n\n  self._inflightRequests++; // Give the first chain the earliest possible opportunity to process\n  // this request before we do any work on it.\n\n  var firstChain = self.firstChain;\n\n  for (var i = 0; i < firstChain.length; i++) {\n    var handle = firstChain[i](req, res); // Limit the range of values we will accept as return results of\n    // first handlers. This helps us maintain forward compatibility by\n    // ensuring users don't rely on undocumented/unspecified behavior.\n\n    assert.ok(handle === true || handle === false || handle === undefined || handle === null, 'Return value of first[' + i + '] must be: ' + 'boolean, undefined, or null'); // If the first handler returns false, stop handling the request\n    // immediately.\n\n    if (handle === false) {\n      self._inflightRequests--;\n      return;\n    }\n  }\n\n  this.emit('request', req, res); // Skip Socket.io endpoints\n\n  if (this.socketio && /^\\/socket\\.io.*/.test(req.url)) {\n    self._inflightRequests--;\n    return;\n  } // Decorate req and res objects\n\n\n  self._setupRequest(req, res); // Run in domain to catch async errors\n  // It has significant negative performance impact\n  // Warning: this feature depends on the deprecated domains module\n\n\n  if (self.handleUncaughtExceptions) {\n    var handlerDomain = domain.create();\n    handlerDomain.add(req);\n    handlerDomain.add(res);\n    handlerDomain.on('error', function onError(err) {\n      self._onHandlerError(err, req, res, true);\n    });\n    handlerDomain.run(function run() {\n      self._runPre(req, res);\n    });\n  } else {\n    self._runPre(req, res);\n  }\n};\n/**\n * Run pre handlers\n *\n * @private\n * @memberof Server\n * @instance\n * @function _runPre\n * @param    {Object}    req - the request object\n * @param    {Object}    res - the response object\n * @returns  {undefined} no return value\n * @fires Request,Response#request\n */\n\n\nServer.prototype._runPre = function _runPre(req, res) {\n  var self = this; // emit 'pre' event before we run the pre handlers\n\n  self.emit('pre', req, res); // Run \"pre\"\n\n  req._currentHandler = 'pre';\n  req._timePreStart = process.hrtime();\n  self.preChain.run(req, res, function preChainDone(err) {\n    // Execution time of a handler with error can be significantly lower\n    req._timePreEnd = process.hrtime();\n\n    self._afterPre(err, req, res);\n  });\n};\n/**\n * After pre handlers finished\n *\n * @private\n * @memberof Server\n * @instance\n * @function _afterPre\n * @param  {Error|false|undefined} err - pre handler error\n * @param  {Request} req - request\n * @param  {Response} res - response\n * @returns {undefined} no return value\n */\n\n\nServer.prototype._afterPre = function _afterPre(err, req, res) {\n  var self = this; // Handle error\n\n  if (err) {\n    self._onHandlerError(err, req, res);\n\n    self._finishReqResCycle(req, res, err);\n\n    return;\n  } // Stop\n\n\n  if (err === false) {\n    self._onHandlerStop(req, res);\n\n    return;\n  }\n\n  self._runRoute(req, res);\n};\n/**\n * Find route and run handlers\n *\n * @private\n * @memberof Server\n * @instance\n * @function _runRoute\n * @param    {Object}    req - the request object\n * @param    {Object}    res - the response object\n * @returns  {undefined} no return value\n * @fires Request,Response#request\n */\n\n\nServer.prototype._runRoute = function _runRoute(req, res) {\n  var self = this;\n  var routeHandler = self.router.lookup(req, res);\n\n  if (!routeHandler) {\n    self.router.defaultRoute(req, res, function afterRouter(err) {\n      self._afterRoute(err, req, res);\n    });\n    return;\n  } // Emit routed\n\n\n  self.emit('routed', req, res, req.route);\n\n  self._runUse(req, res, function afterUse() {\n    // DTrace\n    if (self.dtrace) {\n      dtrace._rstfy_probes['route-start'].fire(function fire() {\n        return [self.name, req.route.name, req._dtraceId, req.method, req.href(), req.headers];\n      });\n    }\n\n    req._timeRouteStart = process.hrtime();\n    routeHandler(req, res, function afterRouter(err) {\n      // Execution time of a handler with error can be significantly lower\n      req._timeRouteEnd = process.hrtime(); // DTrace\n\n      if (self.dtrace) {\n        dtrace._rstfy_probes['route-done'].fire(function fire() {\n          return [self.name, req.route.name, req._dtraceId, res.statusCode || 200, res.headers];\n        });\n      }\n\n      self._afterRoute(err, req, res);\n    });\n  });\n};\n/**\n * After use handlers finished\n *\n * @private\n * @memberof Server\n * @instance\n * @function _afterRoute\n * @param  {Error|false|undefined} err - use handler error\n * @param  {Request} req - request\n * @param  {Response} res - response\n * @returns {undefined} no return value\n */\n\n\nServer.prototype._afterRoute = function _afterRoute(err, req, res) {\n  var self = this;\n  res._handlersFinished = true; // Handle error\n\n  if (err) {\n    self._onHandlerError(err, req, res);\n\n    self._finishReqResCycle(req, res, err);\n\n    return;\n  } // Trigger finish\n\n\n  self._finishReqResCycle(req, res, err);\n};\n/**\n * Run use handlers\n *\n * @private\n * @memberof Server\n * @instance\n * @function _runUse\n * @param    {Object}    req - the request object\n * @param    {Object}    res - the response object\n * @param    {Function}  next - next\n * @returns  {undefined} no return value\n * @fires Request,Response#request\n */\n\n\nServer.prototype._runUse = function _runUse(req, res, next) {\n  var self = this; // Run \"use\"\n\n  req._currentHandler = 'use';\n  req._timeUseStart = process.hrtime();\n  self.useChain.run(req, res, function useChainDone(err) {\n    // Execution time of a handler with error can be significantly lower\n    req._timeUseEnd = process.hrtime();\n\n    self._afterUse(err, req, res, next);\n  });\n};\n/**\n * After use handlers finished\n *\n * @private\n * @memberof Server\n * @instance\n * @function _afterUse\n * @param  {Error|false|undefined} err - use handler error\n * @param  {Request} req - request\n * @param  {Response} res - response\n * @param  {Function}  next - next\n * @returns {undefined} no return value\n */\n\n\nServer.prototype._afterUse = function _afterUse(err, req, res, next) {\n  var self = this; // Handle error\n\n  if (err) {\n    self._onHandlerError(err, req, res);\n\n    self._finishReqResCycle(req, res, err);\n\n    return;\n  } // Stop\n\n\n  if (err === false) {\n    self._onHandlerStop(req, res);\n\n    return;\n  }\n\n  next();\n};\n/**\n * Runs after next(false) is called\n *\n * @private\n * @memberof Server\n * @instance\n * @function _onHandlerStop\n * @param  {Request} req - request\n * @param  {Response} res - response\n * @returns {undefined} no return value\n */\n\n\nServer.prototype._onHandlerStop = function _onHandlerStop(req, res) {\n  res._handlersFinished = true;\n\n  this._finishReqResCycle(req, res);\n};\n/**\n * After route handlers finished\n * NOTE: only called when last handler calls next([err])\n *\n * @private\n * @memberof Server\n * @instance\n * @function _onHandlerError\n * @param  {Error|String|undefined} err - router handler error or route name\n * @param  {Request} req - request\n * @param  {Response} res - response\n * @param  {boolean} isUncaught - whether the error is uncaught\n * @returns {undefined} no return value\n */\n\n\nServer.prototype._onHandlerError = function _onHandlerError(err, req, res, isUncaught) {\n  var self = this; // Call route by name\n\n  if (!isUncaught && _.isString(err)) {\n    var routeName = err;\n    var routeHandler = self.router.lookupByName(routeName, req, res); // Cannot find route by name, called when next('route-name') doesn't\n    // find any route, it's a 5xx error as it's a programatic error\n\n    if (!routeHandler) {\n      var routeByNameErr = new customErrorTypes.RouteMissingError(\"Route by name doesn't exist\");\n      routeByNameErr.code = 'ENOEXIST';\n\n      self._afterRoute(routeByNameErr, req, res);\n\n      return;\n    }\n\n    routeHandler(req, res, function afterRouter(routeErr) {\n      self._afterRoute(routeErr, req, res);\n    });\n    return;\n  } // Handlers don't continue when error happen\n\n\n  res._handlersFinished = true; // Preserve handler err for finish event\n\n  res.err = res.err || err; // Error happened in router handlers\n\n  self._routeErrorResponse(req, res, err, isUncaught);\n};\n/**\n * Set up the request before routing and execution of handler chain functions.\n *\n * @private\n * @memberof Server\n * @instance\n * @function _setupRequest\n * @param    {Object}    req - the request object\n * @param    {Object}    res - the response object\n * @returns  {undefined} no return value\n */\n\n\nServer.prototype._setupRequest = function _setupRequest(req, res) {\n  var self = this; // Extend request\n\n  req._dtraceId = dtrace.nextId();\n  req.log = res.log = self.log;\n  req._date = new Date();\n  req._timeStart = process.hrtime();\n  req.serverName = self.name;\n  req.params = {};\n  req.timers = [];\n  req.dtrace = self.dtrace; // Extend response\n\n  res.acceptable = self.acceptable;\n  res.formatters = self.formatters;\n  res.req = req;\n  res.serverName = self.name;\n  res._handlersFinished = false;\n  res._flushed = false;\n  res._strictFormatters = this.strictFormatters; // set header only if name isn't empty string\n\n  if (self.name !== '') {\n    res.setHeader('Server', self.name);\n  } // Request lifecycle events\n  // attach a listener for 'aborted' events, this will let us set\n  // a flag so that we can stop processing the request if the client aborts\n  // the connection (or we lose the connection).\n  // we consider a closed request as flushed from metrics point of view\n\n\n  function onReqAborted() {\n    // Request was aborted, override the status code\n    var err = new customErrorTypes.RequestCloseError();\n    err.statusCode = 444; // For backward compatibility we only set connection state to \"close\"\n    // for RequestCloseError, also aborted is always immediatly followed\n    // by a \"close\" event.\n    // We don't set _connectionState to \"close\" in the happy path\n\n    req._connectionState = 'close'; // Set status code and err for audit as req is already closed connection\n\n    res.statusCode = err.statusCode;\n    res.err = err;\n  } // Response lifecycle events\n\n\n  function onResFinish() {\n    var processHrTime = process.hrtime();\n    res._flushed = true;\n    req._timeFlushed = processHrTime; // Response may get flushed before handler callback is triggered\n\n    req._timeFlushed = processHrTime;\n    req._timePreEnd = req._timePreEnd || processHrTime;\n    req._timeUseEnd = req._timeUseEnd || processHrTime;\n    req._timeRouteEnd = req._timeRouteEnd || processHrTime; // In Node < 10 \"close\" event dont fire always\n    // https://github.com/nodejs/node/pull/20611\n\n    self._finishReqResCycle(req, res);\n  } // We are handling when connection is being closed prematurely outside of\n  // restify. It's not because the req is aborted.\n\n\n  function onResClose() {\n    res._flushed = true; // Finish may already set the req._timeFlushed\n\n    req._timeFlushed = req._timeFlushed || process.hrtime();\n\n    self._finishReqResCycle(req, res, res.err);\n  } // Request events\n\n\n  req.once('aborted', onReqAborted); // Response events\n\n  res.once('finish', onResFinish);\n  res.once('close', onResClose); // attach a listener for the response's 'redirect' event\n\n  res.on('redirect', function onRedirect(redirectLocation) {\n    self.emit('redirect', redirectLocation);\n  });\n};\n/**\n * Maintaining the end of the request-response cycle:\n *  - emitting after event\n *  - updating inflight requests metrics\n * Check if the response is finished, and if not, wait for it before firing the\n * response object.\n *\n * @private\n * @memberof Server\n * @instance\n * @function _finishReqResCycle\n * @param {Object} req - the request object\n * @param {Object} res - the response object\n * @param {Object} [err] - a possible error as a result of failed route matching\n * or failed execution of the handler array.\n * @returns {undefined} no return value\n */\n\n\nServer.prototype._finishReqResCycle = function _finishReqResCycle(req, res, err) {\n  var self = this;\n  var route = req.route; // can be undefined when 404 or error\n\n  if (res._finished) {\n    return;\n  }\n\n  if (res._flushed && res._handlersFinished) {\n    // decrement number of requests\n    self._inflightRequests--;\n    res._finished = true;\n    req._timeFinished = process.hrtime(); // after event has signature of function(req, res, route, err) {...}\n\n    var finalErr = err || res.err;\n    req.emit('restifyDone', route, finalErr);\n    self.emit('after', req, res, route, finalErr);\n  } else {\n    // Store error for when the response is flushed and we actually emit the\n    // 'after' event. The \"err\" object passed to this method takes\n    // precedence, but in case it's not set, \"res.err\" may have been already\n    // set by another code path and we want to preserve it. The caveat thus\n    // is that the 'after' event will be emitted with the latest error that\n    // was set before the response is fully flushed. While not ideal, this\n    // is on purpose and accepted as a reasonable trade-off for now.\n    res.err = err || res.err;\n  }\n};\n/**\n * Helper function to, when on router error, emit error events and then\n * flush the err.\n *\n * @private\n * @memberof Server\n * @instance\n * @function _routeErrorResponse\n * @param    {Request}     req -    the request object\n * @param    {Response}    res -    the response object\n * @param    {Error}       err -    error\n * @param    {boolean}     isUncaught - whether the error is uncaught\n * @returns  {undefined} no return value\n */\n\n\nServer.prototype._routeErrorResponse = function _routeErrorResponse(req, res, err, isUncaught) {\n  var self = this;\n\n  if (isUncaught && self.handleUncaughtExceptions && self.listenerCount('uncaughtException') > 1) {\n    self.emit('uncaughtException', req, res, req.route, err, function uncaughtExceptionCompleted() {\n      // We provide a callback to listeners of the 'uncaughtException'\n      // event and we call _finishReqResCycle when that callback is\n      // called so that, in case the actual request/response lifecycle\n      // was completed _before_ the error was thrown or emitted, and\n      // thus _before_ route handlers were marked as \"finished\", we\n      // can still mark the req/res lifecycle as complete.\n      // This edge case can occur when e.g. a client aborts a request\n      // and the route handler that handles that request throws an\n      // uncaught exception _after_ the request was aborted and the\n      // response was closed.\n      self._finishReqResCycle(req, res, err);\n    });\n    return;\n  }\n\n  self._emitErrorEvents(req, res, null, err, function emitError() {\n    // Prevent double handling\n    if (res._sent) {\n      return;\n    } // only automatically send errors that are known (e.g., restify-errors)\n\n\n    if (err instanceof Error && _.isNumber(err.statusCode)) {\n      res.send(err);\n      return;\n    } // if the thrown exception is not really an Error object, e.g.,\n    //    \"throw 'foo';\"\n    // try to do best effort here to pass on that value by casting it to a\n    // string. This should work even for falsy values like 0, false, null,\n    // or undefined.\n\n\n    res.send(new errors.InternalError(String(err)));\n  });\n};\n/**\n * Emit error events when errors are encountered either while attempting to\n * route the request (via router) or while executing the handler chain.\n *\n * @private\n * @memberof Server\n * @instance\n * @function _emitErrorEvents\n * @param    {Object} req -    the request object\n * @param    {Object} res -    the response object\n * @param    {Object} route -  the current route, if applicable\n * @param    {Object} err -    an error object\n * @param    {Object} cb -     callback function\n * @returns  {undefined} no return value\n * @fires Error#restifyError\n */\n\n\nServer.prototype._emitErrorEvents = function _emitErrorEvents(req, res, route, err, cb) {\n  var self = this; // Error can be of any type: undefined, Error, Number, etc. so we need\n  // to protect ourselves from trying to resolve names from non Error objects\n\n  var errName = err && err.name;\n  var normalizedErrName = errName && errEvtNameFromError(err);\n  req.log.trace({\n    err: err,\n    errName: normalizedErrName\n  }, 'entering emitErrorEvents', errName);\n  var errEvtNames = []; // if we have listeners for the specific error, fire those first.\n  // if there's no error name, we should not emit an event\n\n  if (normalizedErrName && self.listeners(normalizedErrName).length > 0) {\n    errEvtNames.push(normalizedErrName);\n  } // or if we have a generic error listener. always fire generic error event\n  // listener afterwards.\n\n\n  if (self.listeners('restifyError').length > 0) {\n    errEvtNames.push('restifyError');\n  } // kick off the async listeners\n\n\n  return vasync.forEachPipeline({\n    inputs: errEvtNames,\n    func: function emitError(errEvtName, vasyncCb) {\n      self.emit(errEvtName, req, res, err, function emitErrDone() {\n        // the error listener may return arbitrary objects, throw\n        // them away and continue on. don't want vasync to take\n        // that error and stop, we want to emit every single event.\n        return vasyncCb();\n      });\n    }\n  }, // eslint-disable-next-line handle-callback-err\n  function onResult(__, results) {\n    // vasync will never return error here since we throw them away.\n    return cb();\n  });\n}; ///--- Helpers\n\n/**\n * Verify and flatten a nested array of request handlers.\n *\n * @private\n * @function argumentsToChain\n * @throws   {TypeError}\n * @param    {Function[]} handlers - pass through of funcs from server.[method]\n * @returns  {Array} request handlers\n */\n\n\nfunction argumentsToChain(handlers) {\n  assert.array(handlers, 'handlers');\n  var chain = []; // A recursive function for unwinding a nested array of handlers into a\n  // single chain.\n\n  function process(array) {\n    for (var i = 0; i < array.length; i++) {\n      if (Array.isArray(array[i])) {\n        // Recursively call on nested arrays\n        process(array[i]);\n        continue;\n      } // If an element of the array isn't an array, ensure it is a\n      // handler function and then push it onto the chain of handlers\n\n\n      assert.func(array[i], 'handler');\n      chain.push(array[i]);\n    }\n\n    return chain;\n  } // Return the chain, note that if `handlers` is an empty array, this will\n  // return an empty array.\n\n\n  return process(handlers);\n}\n/**\n * merge optional formatters with the default formatters to create a single\n * formatters object. the passed in optional formatters object looks like:\n * formatters: {\n *   'application/foo': function formatFoo(req, res, body) {...}\n * }\n * @private\n * @function mergeFormatters\n * @param    {Object} fmt user specified formatters object\n * @returns  {Object}\n */\n\n\nfunction mergeFormatters(fmt) {\n  var arr = [];\n  var obj = {};\n\n  function addFormatter(src, k) {\n    assert.func(src[k], 'formatter');\n    var q = 1.0; // RFC 2616 sec14 - The default value is q=1\n\n    var t = k;\n\n    if (k.indexOf(';') !== -1) {\n      var tmp = k.split(/\\s*;\\s*/);\n      t = tmp[0];\n\n      if (tmp[1].indexOf('q=') !== -1) {\n        q = parseFloat(tmp[1].split('=')[1]);\n      }\n    }\n\n    if (k.indexOf('/') === -1) {\n      k = mime.getType(k);\n    }\n\n    obj[t] = src[k];\n    arr.push({\n      q: q,\n      t: t\n    });\n  }\n\n  Object.keys(formatters).forEach(addFormatter.bind(this, formatters));\n  Object.keys(fmt || {}).forEach(addFormatter.bind(this, fmt || {}));\n  arr = arr.sort(function sort(a, b) {\n    return b.q - a.q;\n  }).map(function map(a) {\n    return a.t;\n  });\n  return {\n    formatters: obj,\n    acceptable: arr\n  };\n}\n/**\n * Map an Error's .name property into the actual event name that is emitted\n * by the restify server object.\n *\n * @function\n * @private errEvtNameFromError\n * @param {Object} err - an error object\n * @returns {String} an event name to emit\n */\n\n\nfunction errEvtNameFromError(err) {\n  if (err.name === 'ResourceNotFoundError') {\n    // remap the name for router errors\n    return 'NotFound';\n  } else if (err.name === 'InvalidVersionError') {\n    // remap the name for router errors\n    return 'VersionNotAllowed';\n  } else if (err.name) {\n    return err.name.replace(/Error$/, '');\n  } // If the err is not an Error, then just return an empty string\n\n\n  return '';\n}\n/**\n * Mounts a chain on the given path against this HTTP verb\n *\n * @private\n * @function serverMethodFactory\n * @param {String} method - name of the HTTP method\n * @returns {Function} factory\n */\n\n\nfunction serverMethodFactory(method) {\n  return function serverMethod(opts) {\n    if (opts instanceof RegExp || typeof opts === 'string') {\n      opts = {\n        path: opts\n      };\n    } else if (typeof opts === 'object') {\n      opts = shallowCopy(opts);\n    } else {\n      throw new TypeError('path (string) required');\n    }\n\n    if (arguments.length < 2) {\n      throw new TypeError('handler (function) required');\n    }\n\n    opts.method = method;\n    opts.path = opts.path || opts.url; // We accept both a variable number of handler functions, a\n    // variable number of nested arrays of handler functions, or a mix\n    // of both\n\n    var handlers = Array.prototype.slice.call(arguments, 1);\n    var chain = argumentsToChain(handlers);\n    var route = this.router.mount(opts, chain);\n    return route.name;\n  };\n}","map":null,"metadata":{},"sourceType":"script"}