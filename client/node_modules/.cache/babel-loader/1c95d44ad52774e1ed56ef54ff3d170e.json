{"ast":null,"code":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n'use strict';\n\nvar url = require('url');\n\nvar sprintf = require('util').format;\n\nvar assert = require('assert-plus');\n\nvar mime = require('mime');\n\nvar Negotiator = require('negotiator');\n\nvar uuid = require('uuid');\n\nvar dtrace = require('./dtrace'); ///-- Helpers\n\n/**\n * Creates and sets negotiator on request if one doesn't already exist,\n * then returns it.\n *\n * @private\n * @function negotiator\n * @param    {Object} req - the request object\n * @returns  {Object}     a negotiator\n */\n\n\nfunction negotiator(req) {\n  var h = req.headers;\n\n  if (!req._negotiator) {\n    req._negotiator = new Negotiator({\n      headers: {\n        accept: h.accept || '*/*',\n        'accept-encoding': h['accept-encoding'] || 'identity'\n      }\n    });\n  }\n\n  return req._negotiator;\n} ///--- API\n\n/**\n * Patch Request object and extends with extra functionalities\n *\n * @private\n * @function patch\n * @param    {http.IncomingMessage|http2.Http2ServerRequest} Request -\n *                                                           Server Request\n * @returns  {undefined} No return value\n */\n\n\nfunction patch(Request) {\n  /**\n   * Wraps all of the node\n   * [http.IncomingMessage](https://nodejs.org/api/http.html)\n   * APIs, events and properties, plus the following.\n   * @class Request\n   * @extends http.IncomingMessage\n   */\n  ///--- Patches\n\n  /**\n   * Builds an absolute URI for the request.\n   *\n   * @private\n   * @memberof Request\n   * @instance\n   * @function absoluteUri\n   * @param    {String} path - a url path\n   * @returns  {String} uri\n   */\n  Request.prototype.absoluteUri = function absoluteUri(path) {\n    assert.string(path, 'path');\n    var protocol = this.isSecure() ? 'https://' : 'http://';\n    var hostname = this.headers.host;\n    return url.resolve(protocol + hostname + this.path() + '/', path);\n  };\n  /**\n   * Check if the Accept header is present, and includes the given type.\n   * When the Accept header is not present true is returned.\n   * Otherwise the given type is matched by an exact match, and then subtypes.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function accepts\n   * @param    {String | String[]} types - an array of accept type headers\n   * @returns  {Boolean} is accepteed\n   * @example\n   * <caption>\n   * You may pass the subtype such as html which is then converted internally\n   * to text/html using the mime lookup table:\n   * </caption>\n   * // Accept: text/html\n   * req.accepts('html');\n   * // => true\n   *\n   * // Accept: text/*; application/json\n   * req.accepts('html');\n   * req.accepts('text/html');\n   * req.accepts('text/plain');\n   * req.accepts('application/json');\n   * // => true\n   *\n   * req.accepts('image/png');\n   * req.accepts('png');\n   * // => false\n   */\n\n\n  Request.prototype.accepts = function accepts(types) {\n    if (typeof types === 'string') {\n      types = [types];\n    }\n\n    types = types.map(function map(t) {\n      assert.string(t, 'type');\n\n      if (t.indexOf('/') === -1) {\n        t = mime.getType(t);\n      }\n\n      return t;\n    });\n    negotiator(this);\n    return this._negotiator.preferredMediaType(types);\n  };\n  /**\n   * Checks if the request accepts the encoding type(s) specified.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function acceptsEncoding\n   * @param    {String | String[]} types - an array of accept type headers\n   * @returns  {Boolean} is accepted encoding\n   */\n\n\n  Request.prototype.acceptsEncoding = function acceptsEncoding(types) {\n    if (typeof types === 'string') {\n      types = [types];\n    }\n\n    assert.arrayOfString(types, 'types');\n    negotiator(this);\n    return this._negotiator.preferredEncoding(types);\n  };\n  /**\n   * Returns the value of the content-length header.\n   *\n   * @private\n   * @memberof Request\n   * @instance\n   * @function getContentLength\n   * @returns {Number} content length\n   */\n\n\n  Request.prototype.getContentLength = function getContentLength() {\n    if (this._clen !== undefined) {\n      return this._clen === false ? undefined : this._clen;\n    } // We should not attempt to read and parse the body of an\n    // Upgrade request, so force Content-Length to zero:\n\n\n    if (this.isUpgradeRequest()) {\n      return 0;\n    }\n\n    var len = this.header('content-length');\n\n    if (!len) {\n      this._clen = false;\n    } else {\n      this._clen = parseInt(len, 10);\n    }\n\n    return this._clen === false ? undefined : this._clen;\n  };\n  /**\n   * Returns the value of the content-length header.\n   * @public\n   * @memberof Request\n   * @instance\n   * @function contentLength\n   * @returns {Number}\n   */\n\n\n  Request.prototype.contentLength = Request.prototype.getContentLength;\n  /**\n   * Returns the value of the content-type header. If a content-type is not\n   * set, this will return a default value of `application/octet-stream`.\n   *\n   * @private\n   * @memberof Request\n   * @instance\n   * @function getContentType\n   * @returns {String} content type\n   */\n\n  Request.prototype.getContentType = function getContentType() {\n    if (this._contentType !== undefined) {\n      return this._contentType;\n    }\n\n    var index;\n    var type = this.headers['content-type'];\n\n    if (!type) {\n      // RFC2616 section 7.2.1\n      this._contentType = 'application/octet-stream';\n    } else if ((index = type.indexOf(';')) === -1) {\n      this._contentType = type;\n    } else {\n      this._contentType = type.substring(0, index);\n    } // #877 content-types need to be case insensitive.\n\n\n    this._contentType = this._contentType.toLowerCase();\n    return this._contentType;\n  };\n  /**\n   * Returns the value of the content-type header. If a content-type is not\n   * set, this will return a default value of `application/octet-stream`\n   * @public\n   * @memberof Request\n   * @instance\n   * @function getContentType\n   * @returns {String} content type\n   */\n\n\n  Request.prototype.contentType = Request.prototype.getContentType;\n  /**\n   * Returns a Date object representing when the request was setup.\n   * Like `time()`, but returns a Date object.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function date\n   * @returns  {Date} date when request began being processed\n   */\n\n  Request.prototype.date = function date() {\n    return this._date;\n  };\n  /**\n   * Retrieves the complete URI requested by the client.\n   *\n   * @private\n   * @memberof Request\n   * @instance\n   * @function getHref\n   * @returns {String} URI\n   */\n\n\n  Request.prototype.getHref = function getHref() {\n    return this.getUrl().href;\n  };\n  /**\n   * Returns the full requested URL.\n   * @public\n   * @memberof Request\n   * @instance\n   * @function href\n   * @returns {String}\n   * @example\n   * // incoming request is http://localhost:3000/foo/bar?a=1\n   * server.get('/:x/bar', function(req, res, next) {\n   *     console.warn(req.href());\n   *     // => /foo/bar/?a=1\n   * });\n   */\n\n\n  Request.prototype.href = Request.prototype.getHref;\n  /**\n   * Retrieves the request uuid. was created when the request was setup.\n   *\n   * @private\n   * @memberof Request\n   * @instance\n   * @function getId\n   * @returns  {String} id\n   */\n\n  Request.prototype.getId = function getId() {\n    if (this._id !== undefined) {\n      return this._id;\n    }\n\n    this._id = uuid.v4();\n    return this._id;\n  };\n  /**\n   * Returns the request id. If a `reqId` value is passed in,\n   * this will become the requestâ€™s new id. The request id is immutable,\n   * and can only be set once. Attempting to set the request id more than\n   * once will cause restify to throw.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function id\n   * @param {String} reqId - request id\n   * @returns {String} id\n   */\n\n\n  Request.prototype.id = function id(reqId) {\n    var self = this;\n\n    if (reqId) {\n      if (self._id) {\n        throw new Error('request id is immutable, cannot be set again!');\n      } else {\n        assert.string(reqId, 'reqId');\n        self._id = reqId;\n        return self._id;\n      }\n    }\n\n    return self.getId();\n  };\n  /**\n   * Retrieves the cleaned up url path.\n   * e.g., /foo?a=1  =>  /foo\n   *\n   * @private\n   * @memberof Request\n   * @instance\n   * @function getPath\n   * @returns  {String} path\n   */\n\n\n  Request.prototype.getPath = function getPath() {\n    return this.getUrl().pathname;\n  };\n  /**\n   * Returns the cleaned up requested URL.\n   * @public\n   * @memberof Request\n   * @instance\n   * @function getPath\n   * @returns  {String}\n   * @example\n   * // incoming request is http://localhost:3000/foo/bar?a=1\n   * server.get('/:x/bar', function(req, res, next) {\n   *     console.warn(req.path());\n   *     // => /foo/bar\n   * });\n   */\n\n\n  Request.prototype.path = Request.prototype.getPath;\n  /**\n   * Returns the raw query string. Returns empty string\n   * if no query string is found.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function getQuery\n   * @returns  {String} query\n   * @example\n   * // incoming request is /foo?a=1\n   * req.getQuery();\n   * // => 'a=1'\n   * @example\n   * <caption>\n   * If the queryParser plugin is used, the parsed query string is\n   * available under the req.query:\n   * </caption>\n   * // incoming request is /foo?a=1\n   * server.use(restify.plugins.queryParser());\n   * req.query;\n   * // => { a: 1 }\n   */\n\n  Request.prototype.getQuery = function getQuery() {\n    // always return a string, because this is the raw query string.\n    // if the queryParser plugin is used, req.query will provide an empty\n    // object fallback.\n    return this.getUrl().query || '';\n  };\n  /**\n   * Returns the raw query string. Returns empty string\n   * if no query string is found\n   * @private\n   * @memberof Request\n   * @instance\n   * @function query\n   * @returns  {String}\n   */\n\n\n  Request.prototype.query = Request.prototype.getQuery;\n  /**\n   * The number of ms since epoch of when this request began being processed.\n   * Like date(), but returns a number.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function time\n   * @returns  {Number} time when request began being processed in epoch:\n   *                    ellapsed milliseconds since\n   *                    January 1, 1970, 00:00:00 UTC\n   */\n\n  Request.prototype.time = function time() {\n    return this._date.getTime();\n  };\n  /**\n   * returns a parsed URL object.\n   *\n   * @private\n   * @memberof Request\n   * @instance\n   * @function getUrl\n   * @returns  {Object} url\n   */\n\n\n  Request.prototype.getUrl = function getUrl() {\n    if (this._cacheURL !== this.url) {\n      this._url = url.parse(this.url);\n      this._cacheURL = this.url;\n    }\n\n    return this._url;\n  };\n  /**\n   * Returns the accept-version header.\n   *\n   * @private\n   * @memberof Request\n   * @instance\n   * @function getVersion\n   * @returns  {String} version\n   */\n\n\n  Request.prototype.getVersion = function getVersion() {\n    if (this._version !== undefined) {\n      return this._version;\n    }\n\n    this._version = this.headers['accept-version'] || this.headers['x-api-version'] || '*';\n    return this._version;\n  };\n  /**\n   * Returns the accept-version header.\n   * @public\n   * @memberof Request\n   * @instance\n   * @function version\n   * @returns  {String}\n   */\n\n\n  Request.prototype.version = Request.prototype.getVersion;\n  /**\n   * Returns the version of the route that matched.\n   *\n   * @private\n   * @memberof Request\n   * @instance\n   * @function matchedVersion\n   * @returns {String} version\n   */\n\n  Request.prototype.matchedVersion = function matchedVersion() {\n    if (this._matchedVersion !== undefined) {\n      return this._matchedVersion;\n    } else {\n      return this.version();\n    }\n  };\n  /**\n   * Get the case-insensitive request header key,\n   * and optionally provide a default value (express-compliant).\n   * Returns any header off the request. also, 'correct' any\n   * correctly spelled 'referrer' header to the actual spelling used.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function header\n   * @param    {String} key - the key of the header\n   * @param    {String} [defaultValue] - default value if header isn't\n   *                                   found on the req\n   * @returns  {String} header value\n   * @example\n   * req.header('Host');\n   * req.header('HOST');\n   * req.header('Accept', '*\\/*');\n   */\n\n\n  Request.prototype.header = function header(key, defaultValue) {\n    assert.string(key, 'key');\n    key = key.toLowerCase();\n\n    if (key === 'referer' || key === 'referrer') {\n      key = 'referer';\n    }\n\n    return this.headers[key] || defaultValue;\n  };\n  /**\n   * Returns any trailer header off the request. Also, 'correct' any\n   * correctly spelled 'referrer' header to the actual spelling used.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function trailer\n   * @param    {String} name - the name of the header\n   * @param    {String} value - default value if header isn't found on the req\n   * @returns  {String} trailer value\n   */\n\n\n  Request.prototype.trailer = function trailer(name, value) {\n    assert.string(name, 'name');\n    name = name.toLowerCase();\n\n    if (name === 'referer' || name === 'referrer') {\n      name = 'referer';\n    }\n\n    return (this.trailers || {})[name] || value;\n  };\n  /**\n   * Check if the incoming request contains the `Content-Type` header field,\n   * and if it contains the given mime type.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function is\n   * @param    {String} type - a content-type header value\n   * @returns  {Boolean} is content-type header\n   * @example\n   * // With Content-Type: text/html; charset=utf-8\n   * req.is('html');\n   * req.is('text/html');\n   * // => true\n   *\n   * // When Content-Type is application/json\n   * req.is('json');\n   * req.is('application/json');\n   * // => true\n   *\n   * req.is('html');\n   * // => false\n   */\n\n\n  Request.prototype.is = function is(type) {\n    assert.string(type, 'type');\n    var contentType = this.getContentType();\n    var matches = true;\n\n    if (!contentType) {\n      return false;\n    }\n\n    if (type.indexOf('/') === -1) {\n      type = mime.getType(type);\n    }\n\n    if (type.indexOf('*') !== -1) {\n      type = type.split('/');\n      contentType = contentType.split('/');\n      matches &= type[0] === '*' || type[0] === contentType[0];\n      matches &= type[1] === '*' || type[1] === contentType[1];\n    } else {\n      matches = contentType === type;\n    }\n\n    return matches;\n  };\n  /**\n   * Check if the incoming request is chunked.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function isChunked\n   * @returns  {Boolean} is chunked\n   */\n\n\n  Request.prototype.isChunked = function isChunked() {\n    return this.headers['transfer-encoding'] === 'chunked';\n  };\n  /**\n   * Check if the incoming request is kept alive.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function isKeepAlive\n   * @returns  {Boolean} is keep alive\n   */\n\n\n  Request.prototype.isKeepAlive = function isKeepAlive() {\n    if (this._keepAlive !== undefined) {\n      return this._keepAlive;\n    }\n\n    if (this.headers.connection) {\n      this._keepAlive = /keep-alive/i.test(this.headers.connection);\n    } else {\n      this._keepAlive = this.httpVersion === '1.0' ? false : true;\n    }\n\n    return this._keepAlive;\n  };\n  /**\n   * Check if the incoming request is encrypted.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function isSecure\n   * @returns  {Boolean} is secure\n   */\n\n\n  Request.prototype.isSecure = function isSecure() {\n    if (this._secure !== undefined) {\n      return this._secure;\n    }\n\n    this._secure = this.connection.encrypted ? true : false;\n    return this._secure;\n  };\n  /**\n   * Check if the incoming request has been upgraded.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function isUpgradeRequest\n   * @returns  {Boolean} is upgraded\n   */\n\n\n  Request.prototype.isUpgradeRequest = function isUpgradeRequest() {\n    if (this._upgradeRequest !== undefined) {\n      return this._upgradeRequest;\n    } else {\n      return false;\n    }\n  };\n  /**\n   * Check if the incoming request is an upload verb.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function isUpload\n   * @returns  {Boolean} is upload\n   */\n\n\n  Request.prototype.isUpload = function isUpload() {\n    var m = this.method;\n    return m === 'PATCH' || m === 'POST' || m === 'PUT';\n  };\n  /**\n   * toString serialization\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function toString\n   * @returns  {String} serialized request\n   */\n\n\n  Request.prototype.toString = function toString() {\n    var headers = '';\n    var self = this;\n    var str;\n    Object.keys(this.headers).forEach(function forEach(k) {\n      headers += sprintf('%s: %s\\n', k, self.headers[k]);\n    });\n    str = sprintf('%s %s HTTP/%s\\n%s', this.method, this.url, this.httpVersion, headers);\n    return str;\n  };\n  /**\n   * Returns the user-agent header.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function userAgent\n   * @returns  {String} user agent\n   */\n\n\n  Request.prototype.userAgent = function userAgent() {\n    return this.headers['user-agent'];\n  };\n  /**\n   * Start the timer for a request handler.\n   * By default, restify uses calls this automatically for all handlers\n   * registered in your handler chain.\n   * However, this can be called manually for nested functions inside the\n   * handler chain to record timing information.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function startHandlerTimer\n   * @param    {String}    handlerName - The name of the handler.\n   * @returns  {undefined} no return value\n   * @example\n   * <caption>\n   * You must explicitly invoke\n   * endHandlerTimer() after invoking this function. Otherwise timing\n   * information will be inaccurate.\n   * </caption>\n   * server.get('/', function fooHandler(req, res, next) {\n   *     vasync.pipeline({\n   *         funcs: [\n   *             function nestedHandler1(req, res, next) {\n   *                 req.startHandlerTimer('nestedHandler1');\n   *                 // do something\n   *                 req.endHandlerTimer('nestedHandler1');\n   *                 return next();\n   *             },\n   *             function nestedHandler1(req, res, next) {\n   *                 req.startHandlerTimer('nestedHandler2');\n   *                 // do something\n   *                 req.endHandlerTimer('nestedHandler2');\n   *                 return next();\n   *\n   *             }...\n   *        ]...\n   *     }, next);\n   * });\n   */\n\n\n  Request.prototype.startHandlerTimer = function startHandlerTimer(handlerName) {\n    var self = this; // For nested handlers, we prepend the top level handler func name\n\n    var name = self._currentHandler === handlerName ? handlerName : self._currentHandler + '-' + handlerName;\n\n    if (!self._timerMap) {\n      self._timerMap = {};\n    }\n\n    self._timerMap[name] = process.hrtime();\n\n    if (self.dtrace) {\n      dtrace._rstfy_probes['handler-start'].fire(function fire() {\n        return [self.serverName, self._currentRoute, // set in server._run\n        name, self._dtraceId];\n      });\n    }\n  };\n  /**\n   * End the timer for a request handler.\n   * You must invoke this function if you called `startRequestHandler` on a\n   * handler. Otherwise the time recorded will be incorrect.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function endHandlerTimer\n   * @param    {String}    handlerName - The name of the handler.\n   * @returns  {undefined} no return value\n   */\n\n\n  Request.prototype.endHandlerTimer = function endHandlerTimer(handlerName) {\n    var self = this; // For nested handlers, we prepend the top level handler func name\n\n    var name = self._currentHandler === handlerName ? handlerName : self._currentHandler + '-' + handlerName;\n\n    if (!self.timers) {\n      self.timers = [];\n    }\n\n    self._timerMap[name] = process.hrtime(self._timerMap[name]);\n    self.timers.push({\n      name: name,\n      time: self._timerMap[name]\n    });\n\n    if (self.dtrace) {\n      dtrace._rstfy_probes['handler-done'].fire(function fire() {\n        return [self.serverName, self._currentRoute, // set in server._run\n        name, self._dtraceId];\n      });\n    }\n  };\n  /**\n   * Returns the connection state of the request. Current possible values are:\n   * - `close` - when the request has been closed by the clien\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function connectionState\n   * @returns {String} connection state (`\"close\"`)\n   */\n\n\n  Request.prototype.connectionState = function connectionState() {\n    var self = this;\n    return self._connectionState;\n  };\n  /**\n   * Returns true when connection state is \"close\"\n   *\n   * @private\n   * @memberof Request\n   * @instance\n   * @function closed\n   * @returns {Boolean} is closed\n   */\n\n\n  Request.prototype.closed = function closed() {\n    var self = this;\n    return self.connectionState() === 'close';\n  };\n  /**\n   * Returns the route object to which the current request was matched to.\n   *\n   * @public\n   * @memberof Request\n   * @instance\n   * @function getRoute\n   * @returns {Object} route\n   * @example\n   * <caption>Route info object structure:</caption>\n   * {\n   *  path: '/ping/:name',\n   *  method: 'GET',\n   *  versions: [],\n   *  name: 'getpingname'\n   * }\n   */\n\n\n  Request.prototype.getRoute = function getRoute() {\n    var self = this;\n    return self.route;\n  };\n}\n\nmodule.exports = patch;","map":null,"metadata":{},"sourceType":"script"}