{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar net = require('net');\n\nvar util = require('util');\n\nvar transport = require('spdy-transport');\n\nvar debug = require('debug')('spdy:client'); // Node.js 0.10 and 0.12 support\n\n\nObject.assign = process.versions.modules >= 46 ? Object.assign // eslint-disable-next-line\n: util._extend;\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar spdy = require('../spdy');\n\nvar mode = /^v0\\.8\\./.test(process.version) ? 'rusty' : /^v0\\.(9|10)\\./.test(process.version) ? 'old' : /^v0\\.12\\./.test(process.version) ? 'normal' : 'modern';\nvar proto = {};\n\nfunction instantiate(base) {\n  function Agent(options) {\n    this._init(base, options);\n  }\n\n  util.inherits(Agent, base);\n\n  Agent.create = function create(options) {\n    return new Agent(options);\n  };\n\n  Object.keys(proto).forEach(function (key) {\n    Agent.prototype[key] = proto[key];\n  });\n  return Agent;\n}\n\nproto._init = function _init(base, options) {\n  base.call(this, options);\n  var state = {};\n  this._spdyState = state;\n  state.host = options.host;\n  state.options = options.spdy || {};\n  state.secure = this instanceof https.Agent;\n  state.fallback = false;\n  state.createSocket = this._getCreateSocket();\n  state.socket = null;\n  state.connection = null; // No chunked encoding\n\n  this.keepAlive = false;\n  var self = this;\n\n  this._connect(options, function (err, connection) {\n    if (err) {\n      return self.emit('error', err);\n    }\n\n    state.connection = connection;\n    self.emit('_connect');\n  });\n};\n\nproto._getCreateSocket = function _getCreateSocket() {\n  // Find super's `createSocket` method\n  var createSocket;\n  var cons = this.constructor.super_;\n\n  do {\n    createSocket = cons.prototype.createSocket;\n\n    if (cons.super_ === EventEmitter || !cons.super_) {\n      break;\n    }\n\n    cons = cons.super_;\n  } while (!createSocket);\n\n  if (!createSocket) {\n    createSocket = http.Agent.prototype.createSocket;\n  }\n\n  assert(createSocket, '.createSocket() method not found');\n  return createSocket;\n};\n\nproto._connect = function _connect(options, callback) {\n  var state = this._spdyState;\n  var protocols = state.options.protocols || ['h2', 'spdy/3.1', 'spdy/3', 'spdy/2', 'http/1.1', 'http/1.0']; // TODO(indutny): reconnect automatically?\n\n  var socket = this.createConnection(Object.assign({\n    NPNProtocols: protocols,\n    ALPNProtocols: protocols,\n    servername: options.servername || options.host\n  }, options));\n  state.socket = socket;\n  socket.setNoDelay(true);\n\n  function onError(err) {\n    return callback(err);\n  }\n\n  socket.on('error', onError);\n  socket.on(state.secure ? 'secureConnect' : 'connect', function () {\n    socket.removeListener('error', onError);\n    var protocol;\n\n    if (state.secure) {\n      protocol = socket.npnProtocol || socket.alpnProtocol || state.options.protocol;\n    } else {\n      protocol = state.options.protocol;\n    } // HTTP server - kill socket and switch to the fallback mode\n\n\n    if (!protocol || protocol === 'http/1.1' || protocol === 'http/1.0') {\n      debug('activating fallback');\n      socket.destroy();\n      state.fallback = true;\n      return;\n    }\n\n    debug('connected protocol=%j', protocol);\n    var connection = transport.connection.create(socket, Object.assign({\n      protocol: /spdy/.test(protocol) ? 'spdy' : 'http2',\n      isServer: false\n    }, state.options.connection || {})); // Set version when we are certain\n\n    if (protocol === 'h2') {\n      connection.start(4);\n    } else if (protocol === 'spdy/3.1') {\n      connection.start(3.1);\n    } else if (protocol === 'spdy/3') {\n      connection.start(3);\n    } else if (protocol === 'spdy/2') {\n      connection.start(2);\n    } else {\n      socket.destroy();\n      callback(new Error('Unexpected protocol: ' + protocol));\n      return;\n    }\n\n    if (state.options['x-forwarded-for'] !== undefined) {\n      connection.sendXForwardedFor(state.options['x-forwarded-for']);\n    }\n\n    callback(null, connection);\n  });\n};\n\nproto._createSocket = function _createSocket(req, options, callback) {\n  var state = this._spdyState;\n\n  if (state.fallback) {\n    return state.createSocket(req, options);\n  }\n\n  var handle = spdy.handle.create(null, null, state.socket);\n  var socketOptions = {\n    handle: handle,\n    allowHalfOpen: true\n  };\n  var socket;\n\n  if (state.secure) {\n    socket = new spdy.Socket(state.socket, socketOptions);\n  } else {\n    socket = new net.Socket(socketOptions);\n  }\n\n  handle.assignSocket(socket);\n  handle.assignClientRequest(req); // Create stream only once `req.end()` is called\n\n  var self = this;\n  handle.once('needStream', function () {\n    if (state.connection === null) {\n      self.once('_connect', function () {\n        handle.setStream(self._createStream(req, handle));\n      });\n    } else {\n      handle.setStream(self._createStream(req, handle));\n    }\n  }); // Yes, it is in reverse\n\n  req.on('response', function (res) {\n    handle.assignRequest(res);\n  });\n  handle.assignResponse(req); // Handle PUSH\n\n  req.addListener('newListener', spdy.request.onNewListener); // For v0.8\n\n  socket.readable = true;\n  socket.writable = true;\n\n  if (callback) {\n    return callback(null, socket);\n  }\n\n  return socket;\n};\n\nif (mode === 'modern' || mode === 'normal') {\n  proto.createSocket = proto._createSocket;\n} else {\n  proto.createSocket = function createSocket(name, host, port, addr, req) {\n    var state = this._spdyState;\n\n    if (state.fallback) {\n      return state.createSocket(name, host, port, addr, req);\n    }\n\n    return this._createSocket(req, {\n      host: host,\n      port: port\n    });\n  };\n}\n\nproto._createStream = function _createStream(req, handle) {\n  var state = this._spdyState;\n  var self = this;\n  return state.connection.reserveStream({\n    method: req.method,\n    path: req.path,\n    headers: req._headers,\n    host: state.host\n  }, function (err, stream) {\n    if (err) {\n      return self.emit('error', err);\n    }\n\n    stream.on('response', function (status, headers) {\n      handle.emitResponse(status, headers);\n    });\n  });\n}; // Public APIs\n\n\nproto.close = function close(callback) {\n  var state = this._spdyState;\n\n  if (state.connection === null) {\n    this.once('_connect', function () {\n      this.close(callback);\n    });\n    return;\n  }\n\n  state.connection.end(callback);\n};\n\nexports.Agent = instantiate(https.Agent);\nexports.PlainAgent = instantiate(http.Agent);\n\nexports.create = function create(base, options) {\n  if (typeof base === 'object') {\n    options = base;\n    base = null;\n  }\n\n  if (base) {\n    return instantiate(base).create(options);\n  }\n\n  if (options.spdy && options.spdy.plain) {\n    return exports.PlainAgent.create(options);\n  } else {\n    return exports.Agent.create(options);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}