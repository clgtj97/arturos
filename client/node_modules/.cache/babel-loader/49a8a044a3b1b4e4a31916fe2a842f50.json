{"ast":null,"code":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n'use strict';\n\nvar http = require('http');\n\nvar sprintf = require('util').format;\n\nvar url = require('url');\n\nvar assert = require('assert-plus');\n\nvar mime = require('mime');\n\nvar errors = require('restify-errors');\n\nvar httpDate = require('./http_date');\n\nvar utils = require('./utils'); ///--- Globals\n\n\nvar InternalServerError = errors.InternalServerError;\n/**\n * @private\n * Headers that cannot be multi-values.\n * @see #779, multiple set-cookie values are allowed only as multiple headers.\n * @see #986, multiple content-type values / headers disallowed.\n */\n\nvar HEADER_ARRAY_BLACKLIST = {\n  'content-type': true\n}; ///--- API\n\n/**\n * Patch Response object and extends with extra functionalities\n *\n * @private\n * @function patch\n * @param    {http.ServerResponse|http2.Http2ServerResponse} Response -\n *                                                           Server Response\n * @returns  {undefined} No return value\n */\n\nfunction patch(Response) {\n  assert.func(Response, 'Response');\n  /**\n   * Wraps all of the node\n   * [http.ServerResponse](https://nodejs.org/docs/latest/api/http.html)\n   * APIs, events and properties, plus the following.\n   * @class Response\n   * @extends http.ServerResponse\n   */\n\n  /**\n   * Sets the `cache-control` header.\n   *\n   * @public\n   * @memberof Response\n   * @instance\n   * @function cache\n   * @param    {String} [type=\"public\"] - value of the header\n   *                                    (`\"public\"` or `\"private\"`)\n   * @param    {Object} [options] - an options object\n   * @param    {Number} options.maxAge - max-age in seconds\n   * @returns  {String}         the value set to the header\n   */\n\n  Response.prototype.cache = function cache(type, options) {\n    if (typeof type !== 'string') {\n      options = type;\n      type = 'public';\n    }\n\n    if (options && options.maxAge !== undefined) {\n      assert.number(options.maxAge, 'options.maxAge');\n      type += ', max-age=' + options.maxAge;\n    }\n\n    return this.setHeader('Cache-Control', type);\n  };\n  /**\n   * Turns off all cache related headers.\n   *\n   * @public\n   * @memberof Response\n   * @instance\n   * @function noCache\n   * @returns  {Response} self, the response object\n   */\n\n\n  Response.prototype.noCache = function noCache() {\n    // HTTP 1.1\n    this.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate'); // HTTP 1.0\n\n    this.setHeader('Pragma', 'no-cache'); // Proxies\n\n    this.setHeader('Expires', '0');\n    return this;\n  };\n  /**\n   * Appends the provided character set to the response's `Content-Type`.\n   *\n   * @public\n   * @memberof Response\n   * @instance\n   * @function charSet\n   * @param    {String} type - char-set value\n   * @returns  {Response} self, the response object\n   * @example\n   * res.charSet('utf-8');\n   */\n\n\n  Response.prototype.charSet = function charSet(type) {\n    assert.string(type, 'charset');\n    this._charSet = type;\n    return this;\n  };\n  /**\n   * Retrieves a header off the response.\n   *\n   * @private\n   * @memberof Response\n   * @instance\n   * @function get\n   * @param    {Object} name - the header name\n   * @returns  {String} header value\n   */\n\n\n  Response.prototype.get = function get(name) {\n    assert.string(name, 'name');\n    return this.getHeader(name);\n  }; // If getHeaders is not provided by the Node platform, monkey patch our own.\n  // This is needed since versions of Node <7 did not come with a getHeaders.\n  // For more see GH-1408\n\n\n  if (typeof Response.prototype.getHeaders !== 'function') {\n    /**\n     * Retrieves all headers off the response.\n     *\n     * @private\n     * @memberof Response\n     * @instance\n     * @function getHeaders\n     * @returns  {Object} headers\n     */\n    Response.prototype.getHeaders = function getHeaders() {\n      return this._headers || {};\n    };\n  }\n  /**\n   * Sets headers on the response.\n   *\n   * @public\n   * @memberof Response\n   * @instance\n   * @function header\n   * @param    {String} key - the name of the header\n   * @param    {String} value - the value of the header\n   * @returns  {Object} the retrieved value or the value that was set\n   * @example\n   * <caption>\n   * If only key is specified, return the value of the header.\n   * If both key and value are specified, set the response header.\n   * </caption>\n   * res.header('Content-Length');\n   * // => undefined\n   *\n   * res.header('Content-Length', 123);\n   * // => 123\n   *\n   * res.header('Content-Length');\n   * // => 123\n   *\n   * res.header('foo', new Date());\n   * // => Fri, 03 Feb 2012 20:09:58 GMT\n   * @example\n   * <caption>\n   * `header()` can also be used to automatically chain header values\n   * when applicable:\n   * </caption>\n   * res.header('x-foo', 'a');\n   * res.header('x-foo', 'b');\n   * // => { 'x-foo': ['a', 'b'] }\n   * @example\n   * <caption>\n   * Note that certain headers like `content-type`\n   * do not support multiple values, so calling `header()`\n   * twice for those headers will\n   * overwrite the existing value.\n   * </caption>\n   */\n\n\n  Response.prototype.header = function header(key, value) {\n    assert.string(key, 'name');\n\n    if (value === undefined) {\n      return this.getHeader(key);\n    }\n\n    if (value instanceof Date) {\n      value = httpDate(value);\n    } else if (arguments.length > 2) {\n      // Support res.header('foo', 'bar %s', 'baz');\n      var arg = Array.prototype.slice.call(arguments).slice(2);\n      value = sprintf(value, arg);\n    }\n\n    var current = this.getHeader(key); // Check the header blacklist before changing a header to an array\n\n    var keyLc = key.toLowerCase();\n\n    if (current && !(keyLc in HEADER_ARRAY_BLACKLIST)) {\n      if (Array.isArray(current)) {\n        current.push(value);\n        value = current;\n      } else {\n        value = [current, value];\n      }\n    }\n\n    this.setHeader(key, value);\n    return value;\n  };\n  /**\n   * Syntatic sugar for:\n   * ```js\n   * res.contentType = 'json';\n   * res.send({hello: 'world'});\n   * ```\n   *\n   * @public\n   * @memberof Response\n   * @instance\n   * @function json\n   * @param    {Number} [code] -    http status code\n   * @param    {Object} [body] -    value to json.stringify\n   * @param    {Object} [headers] - headers to set on the response\n   * @returns  {Object} the response object\n   * @example\n   * res.header('content-type', 'json');\n   * res.send({hello: 'world'});\n   */\n\n\n  Response.prototype.json = function json(code, body, headers) {\n    this.setHeader('Content-Type', 'application/json');\n    return this.send(code, body, headers);\n  };\n  /**\n   * Sets the link header.\n   *\n   * @public\n   * @memberof Response\n   * @instance\n   * @function link\n   * @param    {String} key -  the link key\n   * @param    {String} value - the link value\n   * @returns  {String}     the header value set to res\n   */\n\n\n  Response.prototype.link = function link(key, value) {\n    assert.string(key, 'key');\n    assert.string(value, 'value');\n\n    var _link = sprintf('<%s>; rel=\"%s\"', key, value);\n\n    return this.header('Link', _link);\n  };\n  /**\n   * Sends the response object. pass through to internal `__send` that uses a\n   * formatter based on the `content-type` header.\n   *\n   * @public\n   * @memberof Response\n   * @instance\n   * @function send\n   * @param    {Number} [code] - http status code\n   * @param    {Object | Buffer | Error} [body] - the content to send\n   * @param    {Object} [headers] - any add'l headers to set\n   * @returns  {Object} the response object\n   * @example\n   * <caption>\n   * You can use send() to wrap up all the usual writeHead(), write(), end()\n   * calls on the HTTP API of node.\n   * You can pass send either a `code` and `body`, or just a body. body can be\n   * an `Object`, a `Buffer`, or an `Error`.\n   * When you call `send()`, restify figures out how to format the response\n   * based on the `content-type`.\n   * </caption>\n   * res.send({hello: 'world'});\n   * res.send(201, {hello: 'world'});\n   * res.send(new BadRequestError('meh'));\n   */\n\n\n  Response.prototype.send = function send(code, body, headers) {\n    var self = this;\n    var sendArgs;\n\n    if (typeof code === 'number') {\n      sendArgs = {\n        code: code,\n        body: body,\n        headers: headers\n      };\n    } else {\n      sendArgs = {\n        body: code,\n        headers: body\n      };\n    }\n\n    sendArgs.format = true;\n    return self.__send(sendArgs);\n  };\n  /**\n   * Like `res.send()`, but skips formatting. This can be useful when the\n   * payload has already been preformatted.\n   * Sends the response object. pass through to internal `__send` that skips\n   * formatters entirely and sends the content as is.\n   *\n   * @public\n   * @memberof Response\n   * @instance\n   * @function sendRaw\n   * @param    {Number} [code] - http status code\n   * @param    {Object | Buffer | Error} [body] - the content to send\n   * @param    {Object} [headers] - any add'l headers to set\n   * @returns  {Object} the response object\n   */\n\n\n  Response.prototype.sendRaw = function sendRaw(code, body, headers) {\n    var self = this;\n    var sendArgs;\n\n    if (typeof code === 'number') {\n      sendArgs = {\n        code: code,\n        body: body,\n        headers: headers\n      };\n    } else {\n      sendArgs = {\n        body: code,\n        headers: body\n      };\n    }\n\n    assert.ok(typeof sendArgs.body === 'string' || Buffer.isBuffer(sendArgs.body), 'res.sendRaw() accepts only strings or buffers');\n    sendArgs.format = false;\n    return self.__send(sendArgs);\n  }; // eslint-disable-next-line jsdoc/check-param-names\n\n  /**\n   * Internal implementation of send. convenience method that handles:\n   * writeHead(), write(), end().\n   *\n   * Both body and headers are optional, but you MUST provide body if you are\n   * providing headers.\n   *\n   * @private\n   * @param {Object} opts - an option sobject\n   * @param {Object | Buffer | String | Error} opts.body - the content to send\n   * @param {Boolean} opts.format - When false, skip formatting\n   * @param {Number} [opts.code] - http status code\n   * @param {Object} [opts.headers] - any add'l headers to set\n   * @returns {Object} - returns the response object\n   */\n\n\n  Response.prototype.__send = function __send(opts) {\n    var self = this;\n    var isHead = self.req.method === 'HEAD';\n    var log = self.log;\n    var code = opts.code;\n    var body = opts.body;\n    var headers = opts.headers || {};\n    self._sent = true; // Now lets try to derive values for optional arguments that we were not\n    // provided, otherwise we choose sane defaults.\n    // If the body is an error object and we were not given a status code,\n    // try to derive it from the error object, otherwise default to 500\n\n    if (!code && body instanceof Error) {\n      code = body.statusCode || 500;\n    } // Set sane defaults for optional arguments if they were not provided\n    // and we failed to derive their values\n\n\n    code = code || self.statusCode || 200; // Populate our response object with the derived arguments\n\n    self.statusCode = code;\n    self._body = body;\n    Object.keys(headers).forEach(function forEach(k) {\n      self.setHeader(k, headers[k]);\n    }); // If log level is set to trace, output our constructed response object\n\n    if (log.trace()) {\n      var _props = {\n        code: self.statusCode,\n        headers: self._headers\n      };\n\n      if (body instanceof Error) {\n        _props.err = self._body;\n      } else {\n        _props.body = self._body;\n      }\n\n      log.trace(_props, 'response::send entered');\n    } // 204 = No Content and 304 = Not Modified, we don't want to send the\n    // body in these cases. HEAD never provides a body.\n\n\n    if (isHead || code === 204 || code === 304) {\n      return flush(self);\n    }\n\n    if (opts.format === true) {\n      // if no body, then no need to format. if this was an error caught\n      // by a domain, don't send the domain error either.\n      if (body === undefined || body instanceof Error && body.domain) {\n        return flush(self);\n      } // At this point we know we have a body that needs to be formatted,\n      // so lets derive the formatter based on the response object's\n      // properties\n\n\n      var formatter;\n      var type = self.contentType || self.getHeader('Content-Type'); // Set Content-Type to application/json when\n      // res.send is called with an Object instead of calling res.json\n\n      if (!type && typeof body === 'object' && !Buffer.isBuffer(body)) {\n        type = 'application/json';\n      } // Derive type if not provided by the user\n\n\n      type = type || self.req.accepts(self.acceptable); // Check to see if we could find a content type to use for the\n      // response.\n\n      if (!type) {\n        return formatterError(self, new errors.NotAcceptableError({\n          message: 'could not find suitable content-type to use ' + 'for the response'\n        }));\n      }\n\n      type = type.split(';')[0];\n\n      if (!self.formatters[type] && type.indexOf('/') === -1) {\n        type = mime.getType(type);\n      } // If finding a formatter matching the negotiated content-type is\n      // required, and we were unable to derive a valid type, default to\n      // treating it as arbitrary binary data per RFC 2046 Section 4.5.1\n\n\n      if (this._strictFormatters && !self.formatters[type] && self.acceptable.indexOf(type) === -1) {\n        type = 'application/octet-stream';\n      }\n\n      formatter = self.formatters[type] || self.formatters['*/*']; // If after the above attempts we were still unable to derive a\n      // formatter, provide a meaningful error message\n\n      if (this._strictFormatters && !formatter) {\n        return formatterError(self, new errors.InternalServerError({\n          message: 'could not find formatter for response ' + 'content-type \"' + type + '\"'\n        }));\n      }\n\n      if (self._charSet) {\n        type = type + '; charset=' + self._charSet;\n      } // Update Content-Type header to the one originally set or to the\n      // type inferred from the most relevant formatter found.\n\n\n      self.setHeader('Content-Type', type);\n\n      if (formatter) {\n        // Finally, invoke the formatter and flush the request with it's\n        // results\n        return flush(self, formatter(self.req, self, body));\n      }\n    }\n\n    return flush(self, body);\n  };\n  /**\n   * Sets multiple header(s) on the response.\n   * Uses `header()` underneath the hood, enabling multi-value headers.\n   *\n   * @public\n   * @memberof Response\n   * @instance\n   * @function set\n   * @param    {String|Object} name - name of the header or\n   *                                `Object` of headers\n   * @param    {String} val - value of the header\n   * @returns  {Object}      self, the response object\n   * @example\n   * res.header('x-foo', 'a');\n   * res.set({\n   *     'x-foo', 'b',\n   *     'content-type': 'application/json'\n   * });\n   * // =>\n   * // {\n   * //    'x-foo': [ 'a', 'b' ],\n   * //    'content-type': 'application/json'\n   * // }\n   */\n\n\n  Response.prototype.set = function set(name, val) {\n    var self = this;\n\n    if (arguments.length === 2) {\n      assert.string(name, 'res.set(name, val) requires name to be a string');\n      this.header(name, val);\n    } else {\n      assert.object(name, 'res.set(headers) requires headers to be an object');\n      Object.keys(name).forEach(function forEach(k) {\n        self.set(k, name[k]);\n      });\n    }\n\n    return this;\n  };\n  /**\n   * Sets the http status code on the response.\n   *\n   * @public\n   * @memberof Response\n   * @instance\n   * @function status\n   * @param    {Number} code - http status code\n   * @returns  {Number}        the status code passed in\n   * @example\n   * res.status(201);\n   */\n\n\n  Response.prototype.status = function status(code) {\n    assert.number(code, 'code');\n    this.statusCode = code;\n    return code;\n  };\n  /**\n   * toString() serialization.\n   *\n   * @private\n   * @memberof Response\n   * @instance\n   * @function toString\n   * @returns  {String} stringified response\n   */\n\n\n  Response.prototype.toString = function toString() {\n    var headers = this.getHeaders();\n    var headerString = '';\n    var str;\n    Object.keys(headers).forEach(function forEach(k) {\n      headerString += k + ': ' + headers[k] + '\\n';\n    });\n    str = sprintf('HTTP/1.1 %s %s\\n%s', this.statusCode, http.STATUS_CODES[this.statusCode], headerString);\n    return str;\n  };\n\n  if (!Response.prototype.hasOwnProperty('_writeHead')) {\n    Response.prototype._writeHead = Response.prototype.writeHead;\n  }\n  /**\n   * Pass through to native response.writeHead()\n   *\n   * @private\n   * @memberof Response\n   * @instance\n   * @function writeHead\n   * @fires    header\n   * @returns  {undefined} no return value\n   */\n\n\n  Response.prototype.writeHead = function restifyWriteHead() {\n    this.emit('header');\n\n    if (this.statusCode === 204 || this.statusCode === 304) {\n      this.removeHeader('Content-Length');\n      this.removeHeader('Content-MD5');\n      this.removeHeader('Content-Type');\n      this.removeHeader('Content-Encoding');\n    }\n\n    this._writeHead.apply(this, arguments);\n  };\n  /**\n   * Redirect is sugar method for redirecting.\n   * @public\n   * @memberof Response\n   * @instance\n   * @param {Object} options url or an options object to configure a redirect\n   * @param {Boolean} [options.secure] whether to redirect to http or https\n   * @param {String} [options.hostname] redirect location's hostname\n   * @param {String} [options.pathname] redirect location's pathname\n   * @param {String} [options.port] redirect location's port number\n   * @param {String} [options.query] redirect location's query string\n   *                                 parameters\n   * @param {Boolean} [options.overrideQuery] if true, `options.query`\n   *                                          stomps over any existing query\n   *                                          parameters on current URL.\n   *                                          by default, will merge the two.\n   * @param {Boolean} [options.permanent] if true, sets 301. defaults to 302.\n   * @param {Function} next mandatory, to complete the response and trigger\n   *                        audit logger.\n   * @fires    redirect\n   * @function redirect\n   * @returns  {undefined}\n   * @example\n   * res.redirect({...}, next);\n   * @example\n   * <caption>\n   * A convenience method for 301/302 redirects. Using this method will tell\n   * restify to stop execution of your handler chain.\n   * You can also use an options object. `next` is required.\n   * </caption>\n   * res.redirect({\n   *   hostname: 'www.foo.com',\n   *   pathname: '/bar',\n   *   port: 80,                 // defaults to 80\n   *   secure: true,             // sets https\n   *   permanent: true,\n   *   query: {\n   *     a: 1\n   *   }\n   * }, next);  // => redirects to 301 https://www.foo.com/bar?a=1\n   */\n\n  /**\n   * Redirect with code and url.\n   * @memberof Response\n   * @instance\n   * @param {Number} code http redirect status code\n   * @param {String} url redirect url\n   * @param {Function} next mandatory, to complete the response and trigger\n   *                        audit logger.\n   * @fires    redirect\n   * @function redirect\n   * @returns  {undefined}\n   * @example\n   * res.redirect(301, 'www.foo.com', next);\n   */\n\n  /**\n   * Redirect with url.\n   * @public\n   * @memberof Response\n   * @instance\n   * @param {String} url redirect url\n   * @param {Function} next mandatory, to complete the response and trigger\n   *                        audit logger.\n   * @fires    redirect\n   * @function redirect\n   * @returns  {undefined}\n   * @example\n   * res.redirect('www.foo.com', next);\n   * res.redirect('/foo', next);\n   */\n\n\n  Response.prototype.redirect = redirect;\n  /**\n   * @private\n   * @param {*} arg1 - arg1\n   * @param {*} arg2 - arg2\n   * @param {*} arg3 - arg3\n   * @fires    redirect\n   * @function redirect\n   * @returns  {undefined} no return value\n   */\n\n  function redirect(arg1, arg2, arg3) {\n    var self = this;\n    var statusCode = 302;\n    var finalUri;\n    var redirectLocation;\n    var next; // 1) this is signature 1, where an explicit status code is passed in.\n    //    MUST guard against null here, passing null is likely indicative\n    //    of an attempt to call res.redirect(null, next);\n    //    as a way to do a reload of the current page.\n\n    if (arg1 && !isNaN(arg1)) {\n      statusCode = arg1;\n      finalUri = arg2;\n      next = arg3;\n    } else if (typeof arg1 === 'string') {\n      // 2) this is signaure number 2\n      // otherwise, it's a string, and use it directly\n      finalUri = arg1;\n      next = arg2;\n    } else if (typeof arg1 === 'object') {\n      // 3) signature number 3, using an options object.\n      // set next, then go to work.\n      next = arg2;\n      var req = self.req;\n      var opt = arg1 || {};\n      var currentFullPath = req.href();\n      var secure = opt.hasOwnProperty('secure') ? opt.secure : req.isSecure(); // if hostname is passed in, use that as the base,\n      // otherwise fall back on current url.\n\n      var parsedUri = url.parse(opt.hostname || currentFullPath, true); // create the object we'll use to format for the final uri.\n      // this object will eventually get passed to url.format().\n      // can't use parsedUri to seed it, as it confuses the url module\n      // with some existing parsed state. instead, we'll pick the things\n      // we want and use that as a starting point.\n\n      finalUri = {\n        port: parsedUri.port,\n        hostname: parsedUri.hostname,\n        query: parsedUri.query,\n        pathname: parsedUri.pathname\n      }; // start building url based on options.\n      // start with the host\n\n      if (opt.hostname) {\n        finalUri.hostname = opt.hostname;\n      } // then set protocol IFF hostname is set - otherwise we end up with\n      // malformed URL.\n\n\n      if (finalUri.hostname) {\n        finalUri.protocol = secure === true ? 'https' : 'http';\n      } // then set current path after the host\n\n\n      if (opt.pathname) {\n        finalUri.pathname = opt.pathname;\n      } // then set port\n\n\n      if (opt.port) {\n        finalUri.port = opt.port;\n      } // then add query params\n\n\n      if (opt.query) {\n        if (opt.overrideQuery === true) {\n          finalUri.query = opt.query;\n        } else {\n          finalUri.query = utils.mergeQs(opt.query, finalUri.query);\n        }\n      } // change status code to 301 permanent if specified\n\n\n      if (opt.permanent) {\n        statusCode = 301;\n      }\n    } // if we're missing a next we should probably throw. if user wanted\n    // to redirect but we were unable to do so, we should not continue\n    // down the handler stack.\n\n\n    assert.func(next, 'res.redirect() requires a next param'); // if we are missing a finalized uri\n    // by this point, pass an error to next.\n\n    if (!finalUri) {\n      return next(new InternalServerError('could not construct url'));\n    }\n\n    redirectLocation = url.format(finalUri);\n    self.emit('redirect', redirectLocation); // now we're done constructing url, send the res\n\n    self.send(statusCode, null, {\n      Location: redirectLocation\n    }); // tell server to stop processing the handler stack.\n\n    return next(false);\n  }\n}\n/**\n * Flush takes our constructed response object and sends it to the client\n *\n * @private\n * @function flush\n * @param {Response} res - response\n * @param {String|Buffer} body - response body\n * @returns {Response} response\n */\n\n\nfunction flush(res, body) {\n  assert.ok(body === null || body === undefined || typeof body === 'string' || Buffer.isBuffer(body), 'body must be a string or a Buffer instance');\n  res._data = body; // Flush headers\n\n  res.writeHead(res.statusCode); // Send body if it was provided\n\n  if (res._data) {\n    res.write(res._data);\n  } // Finish request\n\n\n  res.end(); // If log level is set to trace, log the entire response object\n\n  if (res.log.trace()) {\n    res.log.trace({\n      res: res\n    }, 'response sent');\n  } // Return the response object back out to the caller of __send\n\n\n  return res;\n}\n/**\n * formatterError is used to handle any case where we were unable to\n * properly format the provided body\n *\n * @private\n * @function formatterError\n * @param {Response} res - response\n * @param {Error} err - error\n * @returns {Response} response\n */\n\n\nfunction formatterError(res, err) {\n  // If the user provided a non-success error code, we don't want to\n  // mess with it since their error is probably more important than\n  // our inability to format their message.\n  if (res.statusCode >= 200 && res.statusCode < 300) {\n    res.statusCode = err.statusCode;\n  }\n\n  res.log.warn({\n    req: res.req,\n    err: err\n  }, 'error retrieving formatter');\n  return flush(res);\n}\n\nmodule.exports = patch;","map":null,"metadata":{},"sourceType":"script"}