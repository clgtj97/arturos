{"ast":null,"code":"'use strict'; // core modules\n\nvar http = require('http'); // external modules\n\n\nvar _ = require('lodash');\n\nvar assert = require('assert-plus'); // local globals\n\n\nvar INTERNAL_OPTS_KEYS = {\n  'code': true,\n  'restCode': true,\n  'statusCode': true,\n  'toJSON': true,\n  'toString': true\n}; //------------------------------------------------------------------------------\n// constructor arg parsers\n//------------------------------------------------------------------------------\n\n/**\n * helper function for parsing all of the Error constructor variadic sigs.\n * these signatures are all derived from VError.\n * 1) new HttpError(sprintf_args...);\n * 2) new HttpError(anotherErr, sprintf_args);\n * 3) new HttpError({...}, sprintf_args);\n * restify-errors' value is to add support for additional options using the\n * signature #3. this function parses out the arguments specific to\n * restify-errors so that they don't get passed on to VError.\n * @public\n * @param {Object} ctorArgs an 'arguments' object\n * @function parseVErrorArgs\n * @returns {Object}\n */\n\nfunction parseVErrorArgs(ctorArgs) {\n  // to array the inner arguments so it's easier to determine which cases\n  // we are looking at\n  var args = _.toArray(ctorArgs);\n\n  var internalOpts = {};\n  var verrorOpts = {};\n  var verrorArgs;\n\n  if (_.isPlainObject(args[0])) {\n    // split restify-errors options from verror options\n    _.forOwn(args[0], function (val, key) {\n      if (INTERNAL_OPTS_KEYS.hasOwnProperty(key)) {\n        internalOpts[key] = val;\n      } else {\n        verrorOpts[key] = val;\n      }\n    }); // reconstruct verror ctor options from the cleaned up options\n\n\n    verrorArgs = [verrorOpts].concat(_.tail(args));\n  } else {\n    verrorArgs = args;\n  }\n\n  return {\n    // raw arguments to pass to VError constructor\n    verrorArgs: verrorArgs,\n    // restify-errors specific options\n    internalOpts: internalOpts\n  };\n} //------------------------------------------------------------------------------\n// helpers\n//------------------------------------------------------------------------------\n\n/**\n * create an error name from a status code. looks up the description via\n * http.STATUS_CODES, then calls createErrNameFromDesc().\n * @private\n * @function errNameFromCode\n * @param {Number} code an http status code\n * @returns {String}\n */\n\n\nfunction errNameFromCode(code) {\n  assert.number(code, 'code'); // attempt to retrieve status code description, if not available,\n  // fallback on 500.\n\n  var errorDesc = http.STATUS_CODES[code] || http.STATUS_CODES[500];\n  return errNameFromDesc(errorDesc);\n}\n/**\n * used to programatically create http error code names, using the underlying\n * status codes names exposed via the http module.\n * @private\n * @function errNameFromDesc\n * @param {String} desc a description of the error, e.g., 'Not Found'\n * @returns {String}\n */\n\n\nfunction errNameFromDesc(desc) {\n  assert.string(desc, 'desc'); // takes an error description, split on spaces, camel case it correctly,\n  // then append 'Error' at the end of it.\n  // e.g., the passed in description is 'Internal Server Error'\n  //       the output is 'InternalServerError'\n\n  var pieces = desc.split(/\\s+/);\n\n  var name = _.reduce(pieces, function (acc, piece) {\n    // lowercase all, then capitalize it.\n    var normalizedPiece = _.capitalize(piece.toLowerCase());\n\n    return acc + normalizedPiece;\n  }, ''); // strip all non word characters\n\n\n  name = name.replace(/\\W+/g, ''); // append 'Error' at the end of it only if it doesn't already end with it.\n\n  if (!_.endsWith(name, 'Error')) {\n    name += 'Error';\n  }\n\n  return name;\n}\n\nmodule.exports = {\n  errNameFromCode: errNameFromCode,\n  errNameFromDesc: errNameFromDesc,\n  parseVErrorArgs: parseVErrorArgs\n};","map":null,"metadata":{},"sourceType":"script"}