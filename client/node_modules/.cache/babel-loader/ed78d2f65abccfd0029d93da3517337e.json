{"ast":null,"code":"'use strict';\n\nvar assert = require('assert-plus');\n\nvar GatewayTimeoutError = require('restify-errors').GatewayTimeoutError;\n/**\n * Request Expiry can be used to throttle requests that have already exceeded\n * their client timeouts. Requests can be sent with a configurable client\n * timeout header, e.g. 'x-request-expiry-time', which gives in absolute ms\n * since epoch, when this request will be timed out by the client.\n *\n * This plugin will throttle all incoming requests via a 504 where\n * 'x-request-expiry-time' less than Date.now() -- since these incoming requests\n * have already been timed out by the client. This prevents the server from\n * processing unnecessary requests.\n *\n * Request expiry will use headers to tell if the incoming request has expired.\n * There are two options for this plugin:\n *  1. Absolute Time\n *     * Time in Milliseconds since Epoch when this request should be\n *     considered expired\n *  2. Timeout\n *     * The request start time is supplied\n *     * A timeout, in milliseconds, is given\n *     * The timeout is added to the request start time to arrive at the\n *       absolute time in which the request is considered expired\n *\n * #### Using an external storage mechanism for key/bucket mappings.\n *\n * By default, the restify throttling plugin uses an in-memory LRU to store\n * mappings between throttling keys (i.e., IP address) to the actual bucket that\n * key is consuming.  If this suits you, you can tune the maximum number of keys\n * to store in memory with `options.maxKeys`; the default is 10000.\n *\n * In some circumstances, you want to offload this into a shared system, such as\n * Redis, if you have a fleet of API servers and you're not getting steady\n * and/or uniform request distribution.  To enable this, you can pass in\n * `options.tokensTable`, which is simply any Object that supports `put` and\n * `get` with a `String` key, and an `Object` value.\n *\n * @public\n * @function requestExpiry\n * @param    {Object} opts - an options object\n * @param    {String} [opts.absoluteHeader] - The header key to be used for\n *                                   the expiry time of each request.\n * @param    {String} opts.startHeader - The header key for the start time\n *                                   of the request.\n * @param    {String} opts.timeoutHeader - The header key for the time in\n *                                   milliseconds that should ellapse before\n *                                   the request is considered expired.\n * @returns  {Function} Handler\n * @example\n * <caption>\n * The only option provided is `header` which is the request header used\n * to specify the client timeout.\n * </caption>\n * server.use(restify.plugins.requestExpiry({\n *     header: 'x-request-expiry-time'\n * });\n */\n\n\nfunction requestExpiry(opts) {\n  assert.object(opts, 'opts');\n  assert.optionalString(opts.absoluteHeader, 'opts.absoluteHeader');\n\n  if (!opts.absoluteHeader) {\n    assert.string(opts.startHeader, 'opts.startHeader');\n    assert.string(opts.timeoutHeader, 'opts.timeoutHeader');\n  }\n\n  var useAbsolute = opts.absoluteHeader !== undefined;\n  var absoluteHeaderKey = opts.absoluteHeader;\n  var startHeaderKey = opts.startHeader;\n  var timeoutHeaderKey = opts.timeoutHeader;\n  return function requestExpirationCheck(req, res, next) {\n    /*\n     * Add check expiry API to to req if it doesn't already exist. We only\n     * add this the first time this handler is run, since this handler\n     * could be used in multiple places in the handler chain.\n     */\n    if (!req._expiryTime) {\n      // if the headers don't exist, then the request will never expire.\n      req._expiryTime = Infinity;\n\n      if (useAbsolute) {\n        var expiryTime = parseInt(req.headers[absoluteHeaderKey], 10);\n\n        if (!isNaN(expiryTime)) {\n          req._expiryTime = expiryTime;\n        }\n      } else {\n        // Use the start time header and add the timeout header to it\n        // to arrive at the expiration time\n        var startTime = parseInt(req.headers[startHeaderKey], 10);\n        var timeout = parseInt(req.headers[timeoutHeaderKey], 10);\n\n        if (!isNaN(startTime) && !isNaN(timeout)) {\n          req._expiryTime = startTime + timeout;\n        }\n      }\n\n      req.isExpired = function isExpired() {\n        return Date.now() > req._expiryTime;\n      };\n    }\n\n    if (req.isExpired()) {\n      // The request has expired\n      return next(new GatewayTimeoutError({\n        message: 'Request has expired',\n        context: {\n          expiryTime: req._expiryTime,\n          mode: opts.absoluteHeader ? 'absolute' : 'relative'\n        }\n      }));\n    } else {\n      // Happy case\n      return next();\n    }\n  };\n}\n\nmodule.exports = requestExpiry;","map":null,"metadata":{},"sourceType":"script"}