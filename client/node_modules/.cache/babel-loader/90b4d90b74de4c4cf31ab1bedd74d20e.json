{"ast":null,"code":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n'use strict';\n\nvar crypto = require('crypto');\n\nvar zlib = require('zlib');\n\nvar assert = require('assert-plus');\n\nvar once = require('once');\n\nvar errors = require('restify-errors'); ///--- Globals\n\n\nvar BadDigestError = errors.BadDigestError;\nvar RequestEntityTooLargeError = errors.RequestEntityTooLargeError;\nvar PayloadTooLargeError = errors.PayloadTooLargeError;\nvar UnsupportedMediaTypeError = errors.UnsupportedMediaTypeError;\nvar MD5_MSG = \"Content-MD5 '%s' didn't match '%s'\"; ///--- Helpers\n\nfunction createBodyWriter(req) {\n  var buffers = [];\n  var contentType = req.contentType();\n  var isText = false;\n\n  if (!contentType || contentType === 'application/json' || contentType === 'application/x-www-form-urlencoded' || contentType === 'multipart/form-data' || contentType.substr(0, 5) === 'text/') {\n    isText = true;\n  }\n\n  req.body = new Buffer(0);\n  return {\n    write: function write(chunk) {\n      buffers.push(chunk);\n    },\n    end: function end() {\n      req.body = Buffer.concat(buffers);\n\n      if (isText) {\n        req.body = req.body.toString('utf8');\n      }\n    }\n  };\n} ///--- API\n\n/**\n * Reads the body of the request.\n *\n * @public\n * @function bodyReader\n * @throws   {BadDigestError | PayloadTooLargeError}\n * @param    {Object} options - an options object\n * @returns  {Function} Handler\n */\n\n\nfunction bodyReader(options) {\n  var opts = options || {};\n  assert.object(opts, 'opts');\n  var maxBodySize = opts.maxBodySize || 0;\n\n  function readBody(req, res, originalNext) {\n    var next = once(originalNext); // #100 don't read the body again if we've read it once\n\n    if (req._readBody) {\n      next();\n      return;\n    } else {\n      req._readBody = true;\n    }\n\n    if (req.getContentLength() === 0 && !req.isChunked() || req.contentType() === 'multipart/form-data' || req.contentType() === 'application/octet-stream') {\n      next();\n      return;\n    }\n\n    var bodyWriter = createBodyWriter(req);\n    var bytesReceived = 0;\n    var digest;\n    var gz;\n    var hash;\n    var md5;\n    var unsupportedContentEncoding;\n\n    if (md5 = req.headers['content-md5']) {\n      hash = crypto.createHash('md5');\n    }\n\n    function done() {\n      bodyWriter.end();\n\n      if (unsupportedContentEncoding) {\n        next(new UnsupportedMediaTypeError({\n          info: {\n            contentEncoding: unsupportedContentEncoding\n          }\n        }, 'content encoding not supported'));\n        return;\n      }\n\n      if (maxBodySize && bytesReceived > maxBodySize) {\n        var msg = 'Request body size exceeds ' + maxBodySize;\n        var err; // Between Node 0.12 and 4 http status code messages changed\n        // RequestEntityTooLarge was changed to PayloadTooLarge\n        // this check is to maintain backwards compatibility\n\n        if (PayloadTooLargeError !== undefined) {\n          err = new PayloadTooLargeError(msg);\n        } else {\n          err = new RequestEntityTooLargeError(msg);\n        }\n\n        next(err);\n        return;\n      }\n\n      if (!req.body.length) {\n        next();\n        return;\n      }\n\n      if (hash && md5 !== (digest = hash.digest('base64'))) {\n        next(new BadDigestError(MD5_MSG, md5, digest));\n        return;\n      }\n\n      next();\n    }\n\n    if (req.headers['content-encoding'] === undefined) {\n      // This handles the original else branch\n      req.once('end', done);\n    } else if (req.headers['content-encoding'] === 'gzip') {\n      gz = zlib.createGunzip();\n      gz.on('data', bodyWriter.write);\n      gz.once('end', done);\n      req.once('end', gz.end.bind(gz));\n    } else {\n      unsupportedContentEncoding = req.headers['content-encoding'];\n      res.setHeader('Accept-Encoding', 'gzip');\n      req.once('end', done);\n    }\n\n    req.on('data', function onRequestData(chunk) {\n      if (maxBodySize) {\n        bytesReceived += chunk.length;\n\n        if (bytesReceived > maxBodySize) {\n          return;\n        }\n      }\n\n      if (hash) {\n        hash.update(chunk, 'binary');\n      }\n\n      if (gz) {\n        gz.write(chunk);\n      } else {\n        bodyWriter.write(chunk);\n      }\n    });\n    req.once('error', next); // add 'close and 'aborted' event handlers so that requests (and their\n    // corresponding memory) don't leak if client stops sending data half\n    // way through a POST request\n\n    req.once('close', next);\n    req.once('aborted', next);\n    req.resume();\n  }\n\n  return readBody;\n}\n\nmodule.exports = bodyReader;","map":null,"metadata":{},"sourceType":"script"}