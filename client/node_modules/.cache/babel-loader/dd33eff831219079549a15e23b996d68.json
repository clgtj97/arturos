{"ast":null,"code":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n'use strict';\n\nvar errors = require('restify-errors'); ///--- Globals\n\n\nvar BadRequestError = errors.BadRequestError;\nvar PreconditionFailedError = errors.PreconditionFailedError;\nvar IF_MATCH_FAIL = \"if-match '%s' didn't match etag '%s'\";\nvar IF_NO_MATCH_FAIL = \"if-none-match '%s' matched etag '%s'\";\nvar IF_MOD_FAIL = \"object was modified at '%s'; if-modified-since '%s'\";\nvar IF_UNMOD_FAIL = \"object was modified at '%s'; if-unmodified-since '%s'\"; ///--- API\n// Reference RFC2616 section 14 for an explanation of what this all does.\n\nfunction checkIfMatch(req, res, next) {\n  var clientETags;\n  var cur;\n  var etag = res.etag || res.getHeader('etag') || '';\n  var ifMatch;\n  var matched = false;\n\n  if (ifMatch = req.headers['if-match']) {\n    clientETags = ifMatch.split(/\\s*,\\s*/);\n\n    for (var i = 0; i < clientETags.length; i++) {\n      cur = clientETags[i]; // only strong comparison\n\n      cur = cur.replace(/^W\\//, '');\n      cur = cur.replace(/^\"(\\w*)\"$/, '$1');\n\n      if (cur === '*' || cur === etag) {\n        matched = true;\n        break;\n      }\n    }\n\n    if (!matched) {\n      var err = new PreconditionFailedError(IF_MATCH_FAIL, ifMatch, etag);\n      return next(err);\n    }\n  }\n\n  return next();\n}\n\nfunction checkIfNoneMatch(req, res, next) {\n  var clientETags;\n  var cur;\n  var etag = res.etag || res.getHeader('etag') || '';\n  var ifNoneMatch;\n  var matched = false;\n\n  if (ifNoneMatch = req.headers['if-none-match']) {\n    clientETags = ifNoneMatch.split(/\\s*,\\s*/);\n\n    for (var i = 0; i < clientETags.length; i++) {\n      cur = clientETags[i]; // ignore weak validation\n\n      cur = cur.replace(/^W\\//, '');\n      cur = cur.replace(/^\"(\\w*)\"$/, '$1');\n\n      if (cur === '*' || cur === etag) {\n        matched = true;\n        break;\n      }\n    }\n\n    if (!matched) {\n      return next();\n    }\n\n    if (req.method !== 'GET' && req.method !== 'HEAD') {\n      var err = new PreconditionFailedError(IF_NO_MATCH_FAIL, ifNoneMatch, etag);\n      return next(err);\n    }\n\n    res.send(304);\n    return next(false);\n  }\n\n  return next();\n}\n\nfunction checkIfModified(req, res, next) {\n  var code;\n  var err;\n  var ctime = req.header('if-modified-since');\n  var mtime = res.mtime || res.header('Last-Modified') || '';\n\n  if (!mtime || !ctime) {\n    next();\n    return;\n  }\n\n  try {\n    //\n    // TODO handle Range header modifications\n    //\n    // Note: this is not technically correct as per 2616 -\n    // 2616 only specifies semantics for GET requests, not\n    // any other method - but using if-modified-since with a\n    // PUT or DELETE seems like returning 412 is sane\n    //\n    if (Date.parse(mtime) <= Date.parse(ctime)) {\n      switch (req.method) {\n        case 'GET':\n        case 'HEAD':\n          code = 304;\n          break;\n\n        default:\n          err = new PreconditionFailedError(IF_MOD_FAIL, mtime, ctime);\n          break;\n      }\n    }\n  } catch (e) {\n    next(new BadRequestError(e.message));\n    return;\n  }\n\n  if (code !== undefined) {\n    res.send(code);\n    next(false);\n    return;\n  }\n\n  next(err);\n}\n\nfunction checkIfUnmodified(req, res, next) {\n  var err;\n  var ctime = req.headers['if-unmodified-since'];\n  var mtime = res.mtime || res.header('Last-Modified') || '';\n\n  if (!mtime || !ctime) {\n    next();\n    return;\n  }\n\n  try {\n    if (Date.parse(mtime) > Date.parse(ctime)) {\n      err = new PreconditionFailedError(IF_UNMOD_FAIL, mtime, ctime);\n    }\n  } catch (e) {\n    next(new BadRequestError(e.message));\n    return;\n  }\n\n  next(err);\n} ///--- Exports\n\n/**\n * Returns a set of plugins that will compare an already set `ETag` header with\n * the client's `If-Match` and `If-None-Match` header, and an already set\n * Last-Modified header with the client's `If-Modified-Since` and\n * `If-Unmodified-Since` header.\n *\n * You can use this handler to let clients do nice HTTP semantics with the\n * \"match\" headers.  Specifically, with this plugin in place, you would set\n * `res.etag=$yourhashhere`, and then this plugin will do one of:\n *\n * - return `304` (Not Modified) [and stop the handler chain]\n * - return `412` (Precondition Failed) [and stop the handler chain]\n * - Allow the request to go through the handler chain.\n *\n * The specific headers this plugin looks at are:\n *\n * - `Last-Modified`\n * - `If-Match`\n * - `If-None-Match`\n * - `If-Modified-Since`\n * - `If-Unmodified-Since`\n *\n * @public\n * @throws {BadRequestError}\n * @throws {PreconditionFailedError}\n * @function conditionalRequest\n * @returns  {Function[]} Handlers\n * @example\n * server.use(restify.plugins.conditionalRequest());\n * @example\n * server.use(function setETag(req, res, next) {\n *   res.header('ETag', 'myETag');\n *   res.header('Last-Modified', new Date());\n * });\n *\n * server.use(restify.plugins.conditionalRequest());\n *\n * server.get('/hello/:name', function(req, res, next) {\n *   res.send('hello ' + req.params.name);\n * });\n */\n\n\nfunction conditionalRequest() {\n  var chain = [checkIfMatch, checkIfNoneMatch, checkIfModified, checkIfUnmodified];\n  return chain;\n}\n\nmodule.exports = conditionalRequest;","map":null,"metadata":{},"sourceType":"script"}