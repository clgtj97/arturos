{"ast":null,"code":"'use strict'; // external modules\n\nvar assert = require('assert-plus');\n\nvar _ = require('lodash');\n\nvar verror = require('verror');\n\nvar domain = require('domain');\n\nvar safeJsonStringify; // try to require optional dependency\n\ntry {\n  // eslint-disable-next-line global-require\n  safeJsonStringify = require('safe-json-stringify');\n} catch (e) {\n  safeJsonStringify = null;\n}\n/**\n * @class ErrorSerializer\n * @param {Object} opts an options object\n */\n\n\nfunction ErrorSerializer(opts) {\n  assert.object(opts, 'opts');\n  assert.bool(opts.topLevelFields, 'opts.topLevelFields');\n  /**\n   * when true, serialize all top level fields found on the Error object\n   * @type {Bool}\n   */\n\n  this._serializeTopLevelFields = opts.topLevelFields;\n  /**\n   * find known fields we don't want to serialize\n   * @type {Array}\n   */\n\n  this._knownFields = this._findKnownFields();\n}\n/**\n * loop through all errors() in a verror.MultiError and build a stack trace\n * output.\n * @private\n * @method _getMultiErrorStack\n * @param {Object} err an error object\n * @returns {String} stack trace string\n */\n\n\nErrorSerializer.prototype._getMultiErrorStack = function _getMultiErrorStack(err) {\n  var self = this;\n  var out = '';\n\n  _.forEach(err.errors(), function (e, idx, errs) {\n    out += 'MultiError ' + (idx + 1) + ' of ' + errs.length + ': ';\n    out += self._getFullErrorStack(e) + '\\n';\n  }); // remove last new line char\n\n\n  out = out.slice(0, -1);\n  return out;\n};\n/**\n * loop through all cause() errors and build a stack trace output\n * @private\n * @method _getFullErrorStack\n * @param {Object} err an error object\n * @returns {String} stack trace string\n */\n\n\nErrorSerializer.prototype._getFullErrorStack = function _getFullErrorStack(err) {\n  var self = this;\n  var e = err;\n  var out = '';\n  var first = true;\n\n  do {\n    if (first !== true) {\n      out += '\\nCaused by: ';\n    } // parse out first new line of stack trace, append context there.\n\n\n    var stackString = (e.stack || e.toString()).split('\\n');\n    out += stackString.shift() + self._getSerializedContext(e);\n    out += stackString.join('\\n');\n    e = typeof e.cause === 'function' ? e.cause() : null;\n    first = false;\n  } while (e);\n\n  return out;\n};\n/* eslint-disable max-len */\n\n/* jscs:disable maximumLineLength */\n\n/**\n * serialize the error context object into a string. borrows liberally from\n * bunyan's serializer:\n * https://github.com/trentm/node-bunyan/blob/6fdc5ff20965b81ab15f8f408fe11917e06306f6/lib/bunyan.js#L865\n * @private\n * @method _getSerializedContext\n * @param {Object} err an error object\n * @return {String} serialized context obj\n */\n\n/* jscs:enable maximumLineLength */\n\n/* eslint-enable max-len */\n\n\nErrorSerializer.prototype._getSerializedContext = function _getSerializedContext(err) {\n  /**\n   * serialize a POJO into a string of the format:\n   *     (key=\"valString\", key2=valInteger, key3={a:valPojo})\n   * @param {Object} obj a POJO to serialize\n   * @return {String}\n   */\n  function serializeIntoEqualString(obj) {\n    var out = '';\n\n    _.forEach(obj, function (val, key) {\n      var stringVal;\n\n      try {\n        stringVal = JSON.stringify(val, safeCycles());\n      } catch (e) {\n        if (safeJsonStringify) {\n          stringVal = safeJsonStringify(val);\n        } else {\n          stringVal = 'unserializable! you can install ' + '\"safe-json\"stringify\" module for safer ' + 'stringification';\n        }\n      }\n\n      out += key + '=' + stringVal + ', ';\n    }); // remove last comma\n\n\n    return out.slice(0, -2);\n  }\n\n  var self = this;\n  var ret = ''; // look for error context in 3 places, in ascending order of precedence:\n  // 1) raw fields on the error object that are not known verror or\n  // restify-error fields\n  // 2) restify-error context fields (restify-errors@ <= 5.x)\n  // 3) verror info field\n\n  var topLevelFields = self._serializeTopLevelFields === true ? _.omit(err, self._knownFields) : {};\n\n  if (topLevelFields.domain instanceof domain.Domain) {\n    topLevelFields = _.omit(topLevelFields, ['domain']);\n  } // combine all fields into a pojo, and serialize\n\n\n  var allFields = _.assign({}, topLevelFields, err.context, verror.info(err));\n\n  if (!_.isEmpty(allFields)) {\n    ret = ' (' + serializeIntoEqualString(allFields) + ')';\n  }\n\n  return ret + '\\n';\n};\n/**\n * find a list of known error fields that we don't want to serialize. create\n * verror instances to programatically build that list.\n * @private\n * @method _findKnownFields\n * @return {Array}\n */\n\n\nErrorSerializer.prototype._findKnownFields = function _findKnownFields() {\n  // when looping through arbitrary fields attached to the error object, cross\n  // reference them against this known list of fields.\n  var fields = [// known Error fields\n  'message', 'name', 'toJSON', // known restify-error fields\n  'toString', 'body']; // make a verror and multierror and find expected fields\n\n  var verr = new verror.VError();\n  var multiErr = new verror.MultiError([verr]);\n  fields.push(_.keys(verr));\n  fields.push(_.keys(Object.getPrototypeOf(verr)));\n  fields.push(_.keys(multiErr));\n  fields.push(_.keys(Object.getPrototypeOf(multiErr)));\n  return _(fields).flatten().uniq().value();\n};\n/**\n * built in bunyan serializer for restify errors. it's more or less the\n * standard bunyan serializer with support for the context property.\n * @private\n * @method serialize\n * @param {Object} err an error object\n * @returns {Object} serialized object for bunyan output\n */\n\n\nErrorSerializer.prototype.serialize = function serialize(err) {\n  if (!err || !err.stack) {\n    return err;\n  }\n\n  var self = this;\n\n  var multiErr = err.errors && _.isFunction(err.errors);\n\n  return {\n    message: err.message,\n    name: err.name,\n    stack: multiErr === true ? self._getMultiErrorStack(err) : self._getFullErrorStack(err),\n    code: err.code,\n    signal: err.signal\n  };\n};\n/**\n * copy pasta-ed from bunyan.\n * A JSON stringifier that handles cycles safely.\n * Usage: JSON.stringify(obj, safeCycles())\n * @returns {Function}\n */\n\n\nfunction safeCycles() {\n  var seen = [];\n  return function (key, val) {\n    if (!val || typeof val !== 'object') {\n      return val;\n    }\n\n    if (seen.indexOf(val) !== -1) {\n      return '[Circular]';\n    }\n\n    seen.push(val);\n    return val;\n  };\n}\n/**\n * factory function to create customized serializers.\n * @public\n * @param {Object} options an options object\n * @return {Function} serializer function\n */\n\n\nfunction factory(options) {\n  assert.optionalObject(options, 'options');\n\n  var opts = _.assign({\n    topLevelFields: false\n  }, options);\n\n  var serializer = new ErrorSerializer(opts); // rebind the serialize function since this will be lost when we export it\n  // as a POJO\n\n  serializer.serialize = serializer.serialize.bind(serializer);\n  return serializer;\n} // we should be exporting this create function, but to refrain from making it a\n// breaking change, let's attach the create to the existing function export. we\n// can make the change in next major version.\n\n\nvar defaultSerializer = factory();\n\ndefaultSerializer.serialize.create = function create(opts) {\n  var serializer = factory(opts);\n  return {\n    err: serializer.serialize\n  };\n};\n\nmodule.exports = defaultSerializer.serialize;","map":null,"metadata":{},"sourceType":"script"}