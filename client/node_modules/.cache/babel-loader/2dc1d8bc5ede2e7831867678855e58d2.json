{"ast":null,"code":"// Copyright 2012 Mark Cavage, Inc.  All rights reserved.\n'use strict';\n\nvar util = require('util');\n\nvar _ = require('lodash');\n\nvar RestError = require('./baseClasses/RestError'); //------------------------------------------------------------------------------\n// local global vars\n//------------------------------------------------------------------------------\n\n\nvar CODES = {\n  BadDigest: 400,\n  BadMethod: 405,\n  ConnectTimeout: 408,\n  Internal: 500,\n  InvalidArgument: 409,\n  InvalidContent: 400,\n  InvalidCredentials: 401,\n  InvalidHeader: 400,\n  InvalidVersion: 400,\n  MissingParameter: 409,\n  NotAuthorized: 403,\n  RequestExpired: 400,\n  RequestThrottled: 429,\n  ResourceNotFound: 404,\n  WrongAccept: 406\n};\n\nvar restErrors = _.reduce(CODES, function (acc, statusCode, errorCode) {\n  // append Error to the end of the name if it doesn't already end with it.\n  // this becomes the name of the constructor\n  var name = errorCode + 'Error'; // this is a dynamic constructor for an error message.\n  // arguments are variadic. constructor fn name must be anonymous.\n\n  /**\n   * Variadic signature, first two are special to Restify, using a options\n   * obj.\n   * 1) new [Dynamic]Error(anotherErr, {...});\n   * 2) new [Dynamic]Error({...});\n   * Last one is a straight pass through to WError\n   * 3) new [Dynamic]Error('my special error message');\n   * @public\n   * @class\n   */\n\n  acc[name] = function () {\n    // call super\n    RestError.apply(this, arguments);\n  };\n\n  util.inherits(acc[name], RestError);\n  /**\n   * assign non-standard display name property on the CONSTRUCTOR (not\n   * prototype), which is supported by all VMs. useful for stack trace\n   * output.\n   * @type {String}\n   */\n\n  acc[name].displayName = name;\n  /**\n   * the name of the error, used in the stack trace output\n   * @type {String}\n   */\n\n  acc[name].prototype.name = name;\n  /**\n   * assign a default status code based on core http module.\n   * users can override this if they want to. HttpError constructor\n   * will handle overriding at the instance level.\n   * @type {Number}\n   */\n\n  acc[name].prototype.statusCode = statusCode;\n  /**\n   * the default rest code. i.e., a BadDigestError has a restCode of\n   * 'BadDigest'.  it is basically the key for the lookup in the CODES\n   * mapping at the top of the file.\n   * @type {String}\n   */\n\n  acc[name].prototype.restCode = errorCode;\n  return acc;\n}, {});\n\nmodule.exports = restErrors;","map":null,"metadata":{},"sourceType":"script"}